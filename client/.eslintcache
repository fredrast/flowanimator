[{"/Users/fredrik/dev/flowanimator/client/src/index.js":"1","/Users/fredrik/dev/flowanimator/client/src/App.js":"2","/Users/fredrik/dev/flowanimator/client/src/serviceWorker.js":"3","/Users/fredrik/dev/flowanimator/client/src/load-modal.js":"4","/Users/fredrik/dev/flowanimator/client/src/control-panel.js":"5","/Users/fredrik/dev/flowanimator/client/src/animation.js":"6","/Users/fredrik/dev/flowanimator/client/src/info-modal.js":"7","/Users/fredrik/dev/flowanimator/client/src/welcome.js":"8","/Users/fredrik/dev/flowanimator/client/src/jira.js":"9","/Users/fredrik/dev/flowanimator/client/src/controls.js":"10","/Users/fredrik/dev/flowanimator/client/src/animation-data.js":"11","/Users/fredrik/dev/flowanimator/client/src/calendar-timeline.js":"12","/Users/fredrik/dev/flowanimator/client/src/slider.js":"13","/Users/fredrik/dev/flowanimator/client/src/column.js":"14","/Users/fredrik/dev/flowanimator/client/src/timer.js":"15","/Users/fredrik/dev/flowanimator/client/src/story.js":"16","/Users/fredrik/dev/flowanimator/client/src/data-area.js":"17","/Users/fredrik/dev/flowanimator/client/src/autocomplete.js":"18","/Users/fredrik/dev/flowanimator/client/src/css-spinner.js":"19","/Users/fredrik/dev/flowanimator/client/src/move.js":"20","/Users/fredrik/dev/flowanimator/client/src/transition.js":"21","/Users/fredrik/dev/flowanimator/client/src/utils.js":"22","/Users/fredrik/dev/flowanimator/client/src/story-popup.js":"23"},{"size":452,"mtime":1591521730000,"results":"24","hashOfConfig":"25"},{"size":3168,"mtime":1595954468000,"results":"26","hashOfConfig":"25"},{"size":4951,"mtime":1591521730000,"results":"27","hashOfConfig":"25"},{"size":14466,"mtime":1609249082518,"results":"28","hashOfConfig":"25"},{"size":3898,"mtime":1595954568000,"results":"29","hashOfConfig":"25"},{"size":7321,"mtime":1595957823000,"results":"30","hashOfConfig":"25"},{"size":7487,"mtime":1595957478000,"results":"31","hashOfConfig":"25"},{"size":990,"mtime":1595954484000,"results":"32","hashOfConfig":"25"},{"size":11088,"mtime":1594579226000,"results":"33","hashOfConfig":"25"},{"size":19056,"mtime":1595961610000,"results":"34","hashOfConfig":"25"},{"size":18832,"mtime":1594579226000,"results":"35","hashOfConfig":"25"},{"size":7127,"mtime":1591521730000,"results":"36","hashOfConfig":"25"},{"size":3451,"mtime":1595955487000,"results":"37","hashOfConfig":"25"},{"size":10398,"mtime":1595951031000,"results":"38","hashOfConfig":"25"},{"size":925,"mtime":1591808182000,"results":"39","hashOfConfig":"25"},{"size":31310,"mtime":1595955400000,"results":"40","hashOfConfig":"25"},{"size":1821,"mtime":1592148820000,"results":"41","hashOfConfig":"25"},{"size":7549,"mtime":1595954448000,"results":"42","hashOfConfig":"25"},{"size":574,"mtime":1591521730000,"results":"43","hashOfConfig":"25"},{"size":6618,"mtime":1591521730000,"results":"44","hashOfConfig":"25"},{"size":4075,"mtime":1591939294000,"results":"45","hashOfConfig":"25"},{"size":6570,"mtime":1591939536000,"results":"46","hashOfConfig":"25"},{"size":4175,"mtime":1591940415000,"results":"47","hashOfConfig":"25"},{"filePath":"48","messages":"49","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50","usedDeprecatedRules":"51"},"1abnsw7",{"filePath":"52","messages":"53","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"54","usedDeprecatedRules":"51"},{"filePath":"55","messages":"56","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"57","usedDeprecatedRules":"51"},{"filePath":"58","messages":"59","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"60","usedDeprecatedRules":"51"},{"filePath":"61","messages":"62","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"63","usedDeprecatedRules":"51"},{"filePath":"64","messages":"65","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"66","usedDeprecatedRules":"51"},{"filePath":"67","messages":"68","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"69","usedDeprecatedRules":"51"},{"filePath":"70","messages":"71","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"72","usedDeprecatedRules":"51"},{"filePath":"73","messages":"74","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"75","usedDeprecatedRules":"51"},{"filePath":"76","messages":"77","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"78","usedDeprecatedRules":"51"},{"filePath":"79","messages":"80","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"81","usedDeprecatedRules":"51"},{"filePath":"82","messages":"83","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"84","usedDeprecatedRules":"51"},{"filePath":"85","messages":"86","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"87","usedDeprecatedRules":"51"},{"filePath":"88","messages":"89","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"90","usedDeprecatedRules":"51"},{"filePath":"91","messages":"92","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"93","usedDeprecatedRules":"51"},{"filePath":"94","messages":"95","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"96","usedDeprecatedRules":"51"},{"filePath":"97","messages":"98","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"99","usedDeprecatedRules":"51"},{"filePath":"100","messages":"101","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"102","usedDeprecatedRules":"51"},{"filePath":"103","messages":"104","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"105","usedDeprecatedRules":"51"},{"filePath":"106","messages":"107","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"108","usedDeprecatedRules":"51"},{"filePath":"109","messages":"110","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"111","usedDeprecatedRules":"51"},{"filePath":"112","messages":"113","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"114","usedDeprecatedRules":"51"},{"filePath":"115","messages":"116","errorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"117"},"/Users/fredrik/dev/flowanimator/client/src/index.js",["118"],"import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n",["119","120","121"],"/Users/fredrik/dev/flowanimator/client/src/App.js",["122"],"import React, { useState } from 'react';\nimport './App.css';\nimport LoadModal from './load-modal.js';\nimport './load-modal.css';\nimport ControlPanel from './control-panel.js';\nimport './control-panel.css';\nimport Animation from './animation.js';\nimport './animation.css';\nimport InfoModal from './info-modal.js';\nimport Welcome from './welcome.js';\n\nfunction App() {\n  const [modalVisible, setModalVisible] = useState(false);\n  const [projectData, setProjectData] = useState(undefined);\n  const [playing, setPlaying] = useState(false);\n  const [animationTime, setAnimationTime] = useState(0);\n  const [showInfo, setShowInfo] = useState(false);\n\n  // useEffect(() => {\n  //   // To auto-load test data without having to go through modal\n  //   const sampleProjectData = require('./test-data/project-data.json');\n  //   setProjectData(sampleProjectData);\n  // }, []);\n\n  const handleOpenClick = () => {\n    setModalVisible(true);\n  };\n  const handlePlayClick = () => {\n    setPlaying(!playing);\n  };\n  const handleStopClick = () => {\n    setPlaying(false);\n    setAnimationTime(0);\n  };\n  const handleModalClose = () => {\n    setModalVisible(false);\n  };\n\n  const passProjectData = projectData => {\n    setProjectData(projectData);\n    // saveJSON(projectData);\n  };\n\n  // function saveJSON(data) {\n  //   let bl = new Blob([JSON.stringify(data)], {\n  //     type: 'application/json',\n  //   });\n  //   let a = document.createElement('a');\n  //   a.href = URL.createObjectURL(bl);\n  //   a.download = 'data.json';\n  //   a.hidden = true;\n  //   document.body.appendChild(a);\n  //   a.innerHTML = 'someinnerhtml';\n  //   a.click();\n  // }\n\n  const handleAnimationFinished = () => {\n    setPlaying(false);\n  };\n  /* console.log('Render App'); */\n\n  const handleDemoClick = () => {\n    const options = {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    };\n\n    fetch('demo', options)\n      .then(response => {\n        if (response.ok) {\n          return response.json();\n        } else {\n          throw new Error(response.status);\n        }\n      })\n      .then(json => {\n        setProjectData(json);\n      })\n      .catch(error => {\n        alert(error);\n      });\n  };\n\n  return (\n    <div className=\"App\">\n      <Welcome visible={projectData === undefined} />\n      <Animation\n        projectData={projectData}\n        playing={playing}\n        handleAnimationFinished={handleAnimationFinished}\n        animationTime={animationTime}\n        setAnimationTime={setAnimationTime}\n      />\n      <ControlPanel\n        playControlsEnabled={projectData !== undefined}\n        playing={playing}\n        handleOpenClick={handleOpenClick}\n        handlePlayClick={handlePlayClick}\n        handleStopClick={handleStopClick}\n        handleDemoClick={handleDemoClick}\n        disabled={modalVisible}\n        setAnimationTime={setAnimationTime}\n        setShowInfo={setShowInfo}\n      />\n      <LoadModal\n        visible={modalVisible}\n        handleModalClose={handleModalClose}\n        passProjectData={passProjectData}\n      />\n      <InfoModal visible={showInfo} setShowInfo={setShowInfo} />\n    </div>\n  );\n}\n\nexport default App;\n","/Users/fredrik/dev/flowanimator/client/src/serviceWorker.js",["123"],"// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","/Users/fredrik/dev/flowanimator/client/src/load-modal.js",["124"],"import React, { useState } from 'react';\nimport Autocomplete from './autocomplete';\nimport './autocomplete.css';\nimport {\n  getBoardsFromJira,\n  getProjectDataFromJira,\n  getBoardsUrl,\n  getIssuesUrl,\n} from './jira.js';\n\nimport {\n  Modal,\n  TextInput,\n  RadioGroup,\n  TabbedPanels,\n  TabPanel,\n  MultiPageForm,\n  FormPage,\n} from './controls.js';\n\n/**\n * @className Modal\n * @description\n * @learningsource https://daveceddia.com/open-modal-in-react/\n * @param\n */\n\nexport default function LoadModal(props) {\n  const [url, setUrl] = useState('');\n\n  /*\n  const updateState = (name, value) => {\n    setState(prevState => {\n      return {\n        ...prevState,\n        [name]: value,\n        nextEnabled: state.userId !== '' && state.url !== '',\n      };\n    });\n  };*/\n\n  /* const handleKeyDown = useCallback(\n    event => {\n      const { handleModalClose } = props;\n      const keys = {\n        // Tab\n        9: () => {\n          // Enforce focus trap\n\n          if (modalRef.current) {\n            const focusableModalElements = Array.from(\n              modalRef.current.querySelectorAll('[tabindex]')\n            )\n              .filter(elem => !elem.disabled)\n              .sort((elemA, elemB) => {\n                return elemA.tabIndex - elemB.tabIndex;\n              });\n\n            const currentSelectedElementIndex = focusableModalElements.indexOf(\n              document.activeElement\n            );\n\n            const movement = event.shiftKey ? -1 : 1;\n            var nextSelectedElementIndex =\n              currentSelectedElementIndex + movement;\n            if (\n              nextSelectedElementIndex < 0 ||\n              nextSelectedElementIndex >= focusableModalElements.length\n            ) {\n              nextSelectedElementIndex = event.shiftKey\n                ? focusableModalElements.length - 1\n                : 0;\n            }\n            const nextSelectedElement =\n              focusableModalElements[nextSelectedElementIndex];\n            nextSelectedElement.focus();\n            event.preventDefault();\n          }\n        },\n      };\n\n      if (keys[event.keyCode]) {\n        keys[event.keyCode]();\n      }\n    },\n    [props, modalRef]\n  );\n\n  useEffect(() => {\n    window.addEventListener('keydown', handleKeyDown, false);\n\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown, false);\n    };\n  }, [handleKeyDown]);\n\n\n*/\n\n  return (\n    <Modal\n      id=\"load-modal\"\n      visible={props.visible}\n      closeModal={props.handleModalClose}\n    >\n      <TabbedPanels\n        id=\"tbpLoadMethod\"\n        tabs={['Load from Jira', 'Paste data']}\n        tabIndex={6}\n      >\n        <TabPanel id=\"panLoadFromJira\">\n          <FormLoadFromJira\n            url={url}\n            setUrl={setUrl}\n            passProjectData={props.passProjectData}\n            handleModalClose={props.handleModalClose}\n          />\n        </TabPanel>\n        <TabPanel id=\"panPaste\">\n          <FormPaste\n            url={url}\n            setUrl={setUrl}\n            passProjectData={props.passProjectData}\n            handleModalClose={props.handleModalClose}\n          />\n        </TabPanel>\n      </TabbedPanels>\n    </Modal>\n  );\n} // Modal\n\nfunction FormLoadFromJira(props) {\n  const [userId, setUserId] = useState('');\n  const [password, setPassword] = useState('');\n  const [corsProxy, setCorsProxy] = useState();\n  const [localCorsProxyPort, setLocalCorsProxyPort] = useState(8080);\n  const [availableBoards, setAvailableBoards] = useState([]);\n  const [suggestions, setSuggestions] = useState([]);\n  const [selectedBoard, setSelectedBoard] = useState();\n  const [loading, setLoading] = useState(false);\n\n  const handleCancel = () => {\n    props.handleModalClose();\n  };\n\n  const handleNext = successCallback => {\n    setLoading(true);\n    const shavedUrl = props.url.replace(/\\/$/, '');\n\n    getBoardsFromJira(\n      shavedUrl,\n      userId,\n      password,\n      corsProxy,\n      localCorsProxyPort\n    )\n      .then(boards => {\n        const newAvailableBoards = [];\n        const newSuggestions = [];\n        boards.forEach(board => {\n          let boardNameAndId = board.name + ' (' + board.id + ')';\n          newAvailableBoards.push({ id: board.id, name: boardNameAndId });\n          newSuggestions.push(boardNameAndId);\n        });\n\n        setAvailableBoards(newAvailableBoards);\n        setSuggestions(newSuggestions);\n        successCallback();\n        setLoading(false);\n      })\n      .catch(error => {\n        alert(error);\n        setLoading(false);\n      });\n    return false;\n  };\n\n  const handleBoardChange = value => {\n    const newSelectedBoard = availableBoards.find(\n      board => board.name === value\n    );\n    setSelectedBoard(newSelectedBoard);\n  };\n\n  const handleGo = () => {\n    setLoading(true);\n\n    getProjectDataFromJira(\n      props.url,\n      userId,\n      password,\n      selectedBoard.id,\n      corsProxy,\n      localCorsProxyPort\n    )\n      .then(projectData => {\n        // Call the callback given in props to pass project data to App\n        if (projectData !== {}) {\n          props.passProjectData(projectData);\n        } else {\n          alert('Reading of project data failed');\n        }\n\n        setLoading(false);\n        props.handleModalClose();\n      })\n      .catch(error => {\n        alert(error);\n        setLoading(false);\n      });\n  };\n\n  return (\n    <MultiPageForm>\n      <FormPage\n        forwardButton={{\n          label: 'Next',\n          onClick: handleNext,\n          disabled: props.url === '' || userId === '' || loading === true,\n          showSpinner: loading,\n        }}\n        backwardButton={{ label: 'Cancel', onClick: handleCancel }}\n        header=\"Enter Jira login details\"\n      >\n        <TextInput\n          tabIndex={7}\n          type=\"text\"\n          id=\"inpUrl\"\n          name=\"url\"\n          required={true}\n          label=\"Server URL\"\n          placeholder=\"Enter Jira server URL\"\n          value={props.url}\n          onChange={event => {\n            props.setUrl(event.target.value);\n          }}\n          autoComplete=\"url\"\n        />\n        <RadioGroup\n          tabIndex={8}\n          id={'corsSelection'}\n          name=\"corsProxy\"\n          label=\"CORS proxy\"\n          value={corsProxy}\n          choices={[\n            { value: 'heroku', label: 'Heroku' },\n            { value: 'localhost', label: 'Local workstation' },\n            { value: 'none', label: 'None' },\n          ]}\n          updateValue={value => setCorsProxy(value)}\n        />\n        <TextInput\n          tabIndex={9}\n          type=\"text\"\n          id=\"inpUserId\"\n          name=\"userId\"\n          required={true}\n          label=\"User ID\"\n          value={userId}\n          onChange={event => {\n            setUserId(event.target.value);\n          }}\n          autoComplete=\"username\"\n        />\n        <TextInput\n          tabIndex={10}\n          type=\"password\"\n          id=\"inpPassword\"\n          name=\"password\"\n          required={true}\n          label=\"Password or API Token\"\n          value={password}\n          onChange={event => {\n            setPassword(event.target.value);\n          }}\n          autoComplete=\"current-password\"\n        />{' '}\n      </FormPage>\n      <FormPage\n        forwardButton={{\n          label: 'Go',\n          onClick: handleGo,\n          disabled: !selectedBoard,\n          showSpinner: loading,\n        }}\n        backwardButton={{ label: 'Back' }}\n        header=\"Select a board from Jira\"\n      >\n        <Autocomplete\n          tabIndex={13}\n          label=\"Board\"\n          placeholder=\"Select board...\"\n          onValueChange={handleBoardChange}\n          suggestions={suggestions}\n        />\n      </FormPage>\n    </MultiPageForm>\n  );\n}\n\nfunction FormPaste(props) {\n  const [boardName, setBoardName] = useState('');\n  const [boardId, setBoardId] = useState('');\n  const [filterId, setFilterId] = useState('');\n  const [pages, setPages] = useState('?');\n  const [maxResults, setMaxResults] = useState(1000);\n  const [pastedBoardData, setPastedBoardData] = useState('');\n  const [parsedBoardData, setParsedBoardData] = useState(undefined);\n  const [pastedIssueData, setPastedIssueData] = useState('');\n  const [parsedIssueData, setParsedIssueData] = useState(undefined);\n\n  const onBoardTextAreaChange = (event, index) => {\n    setPastedBoardData(event.target.value);\n    let newParsedBoardData = undefined;\n\n    try {\n      newParsedBoardData = JSON.parse(event.target.value);\n    } catch (error) {\n      console.log(error);\n    }\n\n    setParsedBoardData(newParsedBoardData);\n  };\n\n  const onIssueTextAreaChange = (event, index) => {\n    const clonedEvent = { ...event };\n\n    setPastedIssueData(prevState => {\n      if (clonedEvent.target) {\n        return { ...prevState, [index]: clonedEvent.target.value };\n      } else {\n        return { ...prevState };\n      }\n    });\n\n    let actualMaxResults = maxResults;\n    let totalIssues = 0;\n    let issues = undefined;\n\n    try {\n      const pastedJSON = JSON.parse(event.target.value);\n      actualMaxResults = pastedJSON.maxResults;\n      totalIssues = pastedJSON.total;\n      issues = pastedJSON.issues;\n    } catch (error) {\n      console.log(error);\n    }\n\n    setParsedIssueData(prevState => {\n      return { ...prevState, [index]: issues };\n    });\n\n    setMaxResults(actualMaxResults);\n\n    if (index === 1) {\n      let numberOfPages;\n      if (totalIssues > 0 && actualMaxResults > 0) {\n        numberOfPages = Math.ceil(totalIssues / actualMaxResults);\n      } else {\n        numberOfPages = '?';\n      }\n      setPages(numberOfPages);\n    }\n  };\n\n  function LinksAndTextAreas(props) {\n    const linksAndTextAreas = [];\n    const numberOfPages = props.pages === '?' ? 1 : props.pages;\n    for (let page = 1; page <= numberOfPages; page++) {\n      linksAndTextAreas.push(\n        <a\n          href={getIssuesUrl(props.url, props.filterId, props.maxResults, page)}\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          tabIndex={props.tabIndex + (page - 1) * 2}\n          key={'link' + page}\n        >\n          {2 + (page - 1) * 2}. Access and copy issue data from Jira Rest API\n          (page {page}/{props.pages})\n        </a>\n      );\n\n      linksAndTextAreas.push(\n        <textarea\n          tabIndex={props.tabIndex + (page - 1) * 2 + 1}\n          index={page}\n          name=\"issueData\"\n          key={'textArea' + page}\n          wrap=\"soft\"\n          value={pastedIssueData[page]}\n          placeholder={\n            3 + (page - 1) * 2 + '. Paste issue data from page ' + page\n          }\n          onChange={event => {\n            onIssueTextAreaChange(event, page);\n          }}\n        />\n      );\n    }\n    return linksAndTextAreas;\n  }\n\n  const handleGo = () => {\n    const issues = [];\n\n    for (let index in parsedIssueData) {\n      if (parsedIssueData.hasOwnProperty(index) && parsedIssueData[index]) {\n        issues.push(...parsedIssueData[index]);\n      }\n    }\n\n    const projectData = {\n      serverUrl: props.url,\n      boardConf: parsedBoardData,\n      issues: issues,\n    };\n    props.passProjectData(projectData);\n    props.handleModalClose();\n    return false;\n  };\n\n  const handleCancel = () => {\n    props.handleModalClose();\n    return false;\n  };\n\n  return (\n    <MultiPageForm>\n      <FormPage\n        forwardButton={{\n          label: 'Next',\n          disabled: parsedBoardData === undefined,\n        }}\n        backwardButton={{ label: 'Cancel', onClick: handleCancel }}\n        header=\"Paste board data from Jira REST API\"\n      >\n        {' '}\n        <TextInput\n          tabIndex={7}\n          type=\"text\"\n          name=\"url\"\n          label=\"1. Enter Jira server URL\"\n          placeholder=\"1. Enter Jira server URL\"\n          value={props.url}\n          onChange={props.setUrl}\n        />\n        <a\n          href={props.url}\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          tabIndex={8}\n        >\n          2. Log in to Jira\n        </a>\n        <TextInput\n          tabIndex={9}\n          type=\"text\"\n          name=\"boardName\"\n          label=\"3. Enter name of Jira board\"\n          placeholder=\"3. Enter name of Jira board\"\n          value={boardName}\n          onChange={e => {\n            setBoardName(e.target.value);\n          }}\n        />\n        <a\n          href={getBoardsUrl(props.url, boardName)}\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          tabIndex={10}\n        >\n          4. Look up ID of board from Jira Rest API\n        </a>\n        <TextInput\n          tabIndex={11}\n          type=\"number\"\n          name=\"boardId\"\n          label=\"5. Enter ID of Jira board\"\n          value={boardId}\n          onChange={e => {\n            setBoardId(e.target.value);\n          }}\n        />\n        <a\n          href={\n            props.url.replace(/\\/$/, '') +\n            '/rest/agile/1.0/board/' +\n            boardId +\n            '/configuration'\n          }\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          tabIndex={12}\n        >\n          6. Access and copy board data from Jira Rest API\n        </a>\n        <textarea\n          tabIndex={13}\n          name=\"boardData\"\n          wrap=\"soft\"\n          value={pastedBoardData}\n          placeholder={'7. Paste board data'}\n          onChange={onBoardTextAreaChange}\n        />\n      </FormPage>\n      <FormPage\n        forwardButton={{\n          label: 'Go',\n          onClick: handleGo,\n          disabled: parsedIssueData === undefined,\n        }}\n        backwardButton={{ label: 'Back' }}\n        header=\"Paste issue data from Jira REST API\"\n      >\n        <TextInput\n          tabIndex={14}\n          type=\"number\"\n          id=\"inpFilter\"\n          label=\"1. Enter filter ID\"\n          name=\"filterId\"\n          value={filterId}\n          onChange={e => {\n            setFilterId(e.target.value);\n          }}\n        />\n        <span className=\"hint\">\n          Filter ID found in{' '}\n          <a\n            href={\n              props.url.replace(/\\/$/, '') +\n              '/rest/agile/1.0/board/' +\n              boardId +\n              '/configuration'\n            }\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            board data\n          </a>\n          .\n        </span>\n        <LinksAndTextAreas\n          tabIndex={15}\n          url={props.url}\n          filterId={filterId}\n          pages={pages}\n          maxResults={maxResults}\n        />\n      </FormPage>\n    </MultiPageForm>\n  );\n}\n","/Users/fredrik/dev/flowanimator/client/src/control-panel.js",["125"],"import React, { memo, useState } from 'react';\nimport { useSpring, animated } from 'react-spring';\nimport OpenIcon from './assets/open.svg';\nimport PlayIcon from './assets/play.svg';\nimport PauseIcon from './assets/pause.svg';\nimport StopIcon from './assets/stop.svg';\nimport DemoIcon from './assets/demo.svg';\nimport InfoIcon from './assets/info.svg';\n\nimport HelptextOpen from './assets/helptext-open.svg';\nimport HelptextDemo from './assets/helptext-demo.svg';\nimport HelptextInfo from './assets/helptext-info.svg';\n\nfunction ControlPanel(props) {\n  const [helptextsVisible, setHelptextsVisible] = useState(true);\n\n  const handleOpenClick = () => {\n    setHelptextsVisible(false);\n    props.handleOpenClick();\n  };\n\n  const handleDemoClick = () => {\n    setHelptextsVisible(false);\n    props.handleDemoClick();\n  };\n\n  const handleInfoClick = () => {\n    setHelptextsVisible(false);\n    props.setShowInfo(true);\n  };\n\n  return (\n    <div id=\"control-panel\">\n      <ControlButton\n        id={'button-open'}\n        type={'open'}\n        icon={OpenIcon}\n        tabIndex={1}\n        onClick={handleOpenClick}\n        title=\"Open\"\n        visible={true}\n        helptextImage={HelptextOpen}\n        helptext=\"Click here to get started\"\n        showHelptext={helptextsVisible}\n        helptextNumber=\"1\"\n      />\n      <ControlButton\n        id={'button-play'}\n        type={'play'}\n        icon={props.playing ? PauseIcon : PlayIcon}\n        tabIndex={2}\n        onClick={props.handlePlayClick}\n        visible={true}\n        disabled={!props.playControlsEnabled}\n        title=\"Play\"\n      />\n      <ControlButton\n        id={'button-stop'}\n        type={'stop'}\n        icon={StopIcon}\n        tabIndex={3}\n        onClick={props.handleStopClick}\n        visible={true}\n        disabled={!props.playControlsEnabled}\n        title=\"Stop\"\n      />\n      <ControlButton\n        id={'button-demo'}\n        type={'demo'}\n        icon={DemoIcon}\n        tabIndex={4}\n        onClick={handleDemoClick}\n        visible={true}\n        title=\"Demo\"\n        helptextImage={HelptextDemo}\n        helptext=\"Click here for a demo with sample data \"\n        showHelptext={helptextsVisible}\n        helptextNumber=\"2\"\n      />\n      <ControlButton\n        id={'button-info'}\n        type={'info'}\n        icon={InfoIcon}\n        tabIndex={5}\n        onClick={handleInfoClick}\n        visible={true}\n        title=\"Info\"\n        helptextImage={HelptextInfo}\n        helptext=\"Click here for further information\"\n        showHelptext={helptextsVisible}\n        helptextNumber=\"3\"\n      />{' '}\n    </div>\n  );\n}\n\nfunction ControlButton(props) {\n  if (props.visible) {\n    return (\n      <div className=\"button-wrapper\">\n        <Helptext\n          id={props.id + '-helptext'}\n          number={props.helptextNumber}\n          visible={props.showHelptext}\n          image={props.helptextImage}\n          text={props.helptext}\n        />\n        <button\n          id={props.id}\n          className={'control-button'}\n          tabIndex={props.tabIndex}\n          onClick={props.onClick}\n          disabled={props.disabled}\n          title={props.title}\n        >\n          <img src={props.icon} className={'icon'} alt={props.type} />\n        </button>\n      </div>\n    );\n  } else {\n    return null;\n  }\n}\n\nfunction Helptext(props) {\n  const [appearing, setAppearing] = useState(false);\n\n  const animation = useSpring({\n    config: { mass: 2, tension: 100, friction: 20, velocity: 10 },\n    opacity: appearing ? 1 : 0,\n    top: -125,\n    from: { top: 100, opacity: 0 },\n    delay: 200 + props.number * 1000,\n    onStart: () => {\n      setAppearing(true);\n    },\n  });\n\n  if (props.visible) {\n    return (\n      <animated.img\n        src={props.image}\n        id={props.id}\n        className={'helptext'}\n        style={animation}\n      />\n    );\n  } else {\n    return null;\n  }\n}\n\nexport default memo(ControlPanel);\n","/Users/fredrik/dev/flowanimator/client/src/animation.js",["126"],"import React, { useState, useEffect, memo } from 'react';\nimport { AnimationData } from './animation-data.js';\nimport CalendarTimeline from './calendar-timeline.js';\nimport Slider from './slider.js';\n// import { useWindowDimensions } from './hooks.js';\nimport './animation.css';\nimport ColumnLabels from './column.js';\nimport StoryTokens from './story.js';\nimport Timer from './timer.js';\nimport DataArea from './data-area.js';\n\nconst MARGIN_PERCENTAGE = 0.12;\nconst MIN_MARGIN = 50;\nconst MAX_MARGIN = 50;\n\nfunction Animation(props) {\n  /* console.log('Render Animation'); */\n\n  // TODO: consider better name for state, e.g. animationState or animationData\n  const [state, setState] = useState({\n    projectDataLoaded: false,\n    columns: {},\n    stories: {},\n    projectTimespan: 0,\n    animationDuration: 0,\n    loadProgress: 0,\n    animationBuildInProgress: false,\n    animationTimeToCalendarDate: undefined,\n  });\n\n  // const [animationTime, setAnimationTime] = useState(0);\n\n  const animationTime = props.animationTime;\n  const setAnimationTime = props.setAnimationTime;\n\n  const [timer] = useState(\n    new Timer(setAnimationTime, props.handleAnimationFinished)\n  );\n  const [windowDimensions, setWindowDimensions] = useState(\n    getWindowDimensions()\n  );\n  const clickNewAnimationTime = animationTime => {\n    const MINIMMUM_ANIMATION_TIME_CHANGE = 80;\n    setAnimationTime(previousAnimationTime => {\n      // Only update animation time if the new animation time clicked by\n      // the user differs sufficiently from the previously set one; this is\n      // to avoid too frequent updating of token positions while dragging\n      // the slider button\n      if (\n        Math.abs(animationTime - previousAnimationTime) >=\n        MINIMMUM_ANIMATION_TIME_CHANGE\n      ) {\n        return animationTime;\n      } else {\n        return previousAnimationTime;\n      }\n    });\n  };\n\n  /*** Hook for updating load progress to timer as the animation build proceeds  ***/\n  useEffect(() => {\n    if (timer) {\n      timer.setLoadProgress(state.loadProgress);\n    }\n  }, [timer, state.loadProgress]);\n\n  /*** Hook for building animation when new project data received ***/\n  useEffect(() => {\n    if (props.projectData) {\n      // Use state variable animationBuildInProgress to avoid (accidentally)\n      // starting a new animation build round while the previous is running.\n      if (!state.animationBuildInProgress) {\n        setState(prevState => {\n          return {\n            ...prevState,\n            animationBuildInProgress: true,\n          };\n        });\n        // R  eset animation time to 0.\n        setAnimationTime(0);\n        /* console.log('Launching getAnimationData...'); */\n\n        const {\n          columns,\n          stories,\n          projectTimespan_initial,\n          animationDuration_initial,\n          animationTimeToCalendarDate,\n        } = AnimationData.getAnimationData(props.projectData);\n        /* console.log('getAnimationData completed, updating state'); */\n        /* console.log('Animation:'); */\n        /* console.log('projectTimespan_initial is'); */\n        /* console.log(projectTimespan_initial); */\n        /* console.log('Update state after getAnimationData'); */\n        setState(prevState => {\n          return {\n            ...prevState,\n            projectDataLoaded: true,\n            columns: columns,\n            stories: stories,\n            projectTimespan: projectTimespan_initial,\n            animationDuration: animationDuration_initial,\n            animationTimeToCalendarDate: animationTimeToCalendarDate,\n          };\n        });\n\n        const progressCallback = ({\n          projectTimespan_updated,\n          animationDuration,\n          loadProgress,\n        }) => {\n          /* console.log(\n            'Starting progressCallback with load progress ' + loadProgress\n          ); */\n\n          setState(prevState => {\n            return {\n              ...prevState,\n              projectTimespan: projectTimespan_updated,\n              animationDuration: animationDuration,\n              loadProgress: loadProgress,\n            };\n          });\n\n          // handleAnimationBuildStarted();\n        };\n\n        const completionCallback = () => {\n          /* console.log('Starting completionCallback...'); */\n\n          setState(prevState => {\n            return {\n              ...prevState,\n              animationBuildInProgress: false,\n            };\n          });\n          /* console.log('...completionCallback completed'); */\n          /* console.log('buildAnimation completed'); */\n        };\n        /* console.log('Launching buildAnimation'); */\n        AnimationData.buildAnimation(\n          stories,\n          progressCallback,\n          completionCallback,\n          animationDuration_initial\n        );\n      } else {\n        /* console.log('Animation Build already in progress, doing nothing'); */\n      }\n    } else {\n      /* console.log('No project data, doing nothing'); */\n    }\n  }, [props.projectData]);\n\n  /*** Hook for starting and stopping the timer as the play/pause status is toggled ***/\n  useEffect(() => {\n    if (timer) {\n      if (props.playing) {\n        timer.play();\n      } else {\n        timer.pause();\n      }\n    }\n  }, [props.playing, timer]);\n\n  /*** Hook for resetting width of display when browser window is resized ***/\n  function getWindowDimensions() {\n    const windowWidth = window.innerWidth;\n    const windowHeight = window.innerHeight;\n    const margin = Math.max(\n      Math.min(MARGIN_PERCENTAGE * windowWidth, MAX_MARGIN),\n      MIN_MARGIN\n    );\n    const contentWidth = windowWidth - 2 * margin;\n    return {\n      windowWidth,\n      windowHeight,\n      contentWidth,\n      margin,\n    };\n  }\n\n  useEffect(() => {\n    function handleResize() {\n      setWindowDimensions(getWindowDimensions());\n    }\n\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  if (state.projectDataLoaded) {\n    return (\n      <React.Fragment>\n        <StoryTokens\n          stories={state.stories}\n          margin={windowDimensions.margin}\n          width={windowDimensions.contentWidth}\n          windowDimensions={windowDimensions}\n          columnCount={\n            state.columns.getCount ? state.columns.getCount() - 1 : 0\n          }\n          animationTime={animationTime}\n        />\n        <ColumnLabels\n          columns={state.columns}\n          margin={windowDimensions.margin}\n          width={windowDimensions.contentWidth}\n        />\n        <Slider\n          timespan={state.projectTimespan}\n          animationDuration={state.animationDuration}\n          loadProgress={state.loadProgress}\n          margin={windowDimensions.margin}\n          width={windowDimensions.contentWidth}\n          animationTime={animationTime}\n          setAnimationTime={clickNewAnimationTime}\n        />\n        <CalendarTimeline\n          timespan={state.projectTimespan}\n          margin={windowDimensions.margin}\n          width={windowDimensions.contentWidth}\n        />\n        <DataArea\n          margin={windowDimensions.margin}\n          animationData={state}\n          animationTime={animationTime}\n        />\n      </React.Fragment>\n    );\n  } else {\n    return <div id=\"animation-board\" />;\n  }\n}\n\nexport default memo(Animation);\n","/Users/fredrik/dev/flowanimator/client/src/info-modal.js",["127"],"import React from 'react';\nimport { Modal } from './controls.js';\nimport OpenIcon from './assets/open.svg';\nimport DemoIcon from './assets/demo.svg';\nimport './info-modal.css';\n\nexport default function InfoModal(props) {\n  const iconStyle = {\n    height: '12px',\n    width: '12px',\n  };\n\n  const closeModal = () => {\n    props.setShowInfo(false);\n  };\n\n  return (\n    <Modal id=\"info-modal\" visible={props.visible} closeModal={closeModal}>\n      <h1>Welcome to Flow Animator!</h1>\n      <h2>About</h2>\n      <span>\n        {' '}\n        The aim of the Flow Animator app is to give you a new perspective on\n        your professional workflows in Jira (product development, service desk,\n        incident management management, or whatever you may be using Jira for)\n        by providing an animated view of your issues have been flowing through\n        the different workflow statuses over time.{' '}\n      </span>\n      <br />{' '}\n      <span>\n        Flow Animator was developed by <b>Fredrik Åström</b> (\n        <a href=\"mailto:fredrik.astrom@iki.fi\">fredrik.astrom@iki.fi</a>,{' '}\n        <a\n          href=\"https://github.com/fredrast\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          github.com/fredrast\n        </a>{' '}\n        <a\n          href=\"https://linkedin.com/in/fredrikastrom\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          linkedin.com/in/fredrikastrom\n        </a>\n        ). This has been my hobby project and exercise for learning JavaScript,\n        CSS and React, and I've also been curious to explore what can be learned\n        from viewing professional workflows as animations. Please feel free to\n        use this tool, hopefully you find it useful! Please provide any\n        comments, questions, bug reports, and possible suggestions for new\n        features to{' '}\n        <a href=\"mailto:fredrik.astrom@iki.fi\">fredrik.astrom@iki.fi</a>.\n        <br />\n        <br />\n        The source can be viewed at{' '}\n        <a\n          href=\"https://github.com/fredrast/flowanimator\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          github.com/fredrast/flowanimator\n        </a>\n        .\n      </span>{' '}\n      <br />\n      <br />\n      <h2>Demo</h2>\n      <span>\n        Click Demo ({' '}\n        <img src={DemoIcon} className={'icon'} alt={'demo'} style={iconStyle} />{' '}\n        ) for a test run with sample data.\n      </span>\n      <br />\n      <br />\n      <h2>Usage</h2>\n      <span>\n        {' '}\n        <b>1. Click Open</b> ({' '}\n        <img src={OpenIcon} className={'icon'} alt={'open'} style={iconStyle} />{' '}\n        ) and enter credentials for logging in to a Jira server: <br />{' '}\n        <ul>\n          <li>\n            <b>Jira server:</b> URL for a Jira Cloud or Jira Server (on-premise)\n            instance{' '}\n          </li>\n          <li>\n            <b>CORS proxy:</b> Option for dealing with CORS (see below){' '}\n          </li>\n          <li>\n            <b>User ID:</b> Your user ID for the Jira instance{' '}\n          </li>\n          <li>\n            <b>Password or API token:</b> For Jira Cloud, you need to{' '}\n            <a\n              href=\"https://confluence.atlassian.com/cloud/api-tokens-938839638.html\"\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              generate an API token\n            </a>{' '}\n            and enter it here. For Jira Server, enter your normal password.\n          </li>\n        </ul>\n        NB These credentials will not be stored anywhere. They will be used for\n        authenticating against a Jira server to retrieve data for the animation.\n        They will remain in the memory of the browser during your session and\n        will be discarded when you close the browser session. Likewise, any data\n        retrieved from Jira will only exist in the browser session of your local\n        workstation and will not be stored permanently anywhere.\n      </span>\n      <br />\n      <span>\n        <b>2. Click Next</b> (and wait a while...)\n      </span>\n      <span>\n        <b>3. Select a Jira board</b> for which to run the animation. The app\n        will retrieve the stories from Jira that match the filter of the\n        selected board and generate an animation of the stories' status\n        transitions over time. The statuses will be mapped to columns in\n        accordance to the mapping logic defined for the selected board in Jira.\n      </span>\n      <span>\n        <b>4. Click Go</b> (and wait a few moments more...).\n      </span>{' '}\n      <br />\n      <span>\n        <b>5. Use the play controls</b> to playback the animation of the\n        stories' transitions. Use the slider bar to jump to a specific date in\n        the animation.\n      </span>\n      <span>\n        <b>6. Click on the stories</b> to see some further data, such as cycle\n        and lead times, and times spent in statuses. The coloring (red) of the\n        issues reflect their age since the moment they got committed for\n        implementation. This is assumed to happen when the ticket moves from the\n        first column to the second. Maximum age coloring is reached at 30 days.\n        This is currently hard-coded but likely to be configurable in the\n        future.\n      </span>\n      <br />\n      <br />\n      <br />\n      <h2>Dealing with CORS</h2>\n      <span>\n        Due to the{' '}\n        <a\n          href=\"https://en.wikipedia.org/wiki/Same-origin_policy\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Same-Origin Security Policy\n        </a>{' '}\n        that browsers are nowadays implementing, some special arrangements are\n        needed to make it possible to load data from a different domain (the\n        domain of your Jira instance) than the one that served the application\n        (herokuapp.com). The options are as follows:\n        <ol>\n          {' '}\n          <li>\n            <b>Heroku</b> - Choose this to use Flow Animator's own CORS gatewey\n            on Heroku. In this case, the communication between your browser and\n            Jira will looop through a server process on Heroku, but no\n            credentials or data will be stored on Heroku. NB this option will\n            not work if your Jira server is behind a corporate firewall, unless\n            you make an opening for requests from{' '}\n            <u>flowanimator.herokuapp.com</u>.\n          </li>\n          <li>\n            <b>localhost</b> - Choose this if you instead run the{' '}\n            <a\n              href=\"https://www.npmjs.com/package/cors-anywhere\"\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              cors-anywhere\n            </a>{' '}\n            CORS proxy on your local workstation. In this case you also need to\n            supply the port number, which by default is 8080.\n          </li>\n          <li>\n            <b>None</b> - Choose this if you use some other way of dealing with\n            CORS, such as\n            <ul>\n              <li>\n                whitelisting <u>flowanimator.heokuapp.com</u> in your Jira\n                server configuration\n              </li>\n              <li>\n                including the URL of a CORS proxy directly in the server URL\n              </li>\n              <li>using a browser plugin to bypass CORS</li>\n            </ul>\n          </li>\n        </ol>\n      </span>\n    </Modal>\n  );\n}\n","/Users/fredrik/dev/flowanimator/client/src/welcome.js",["128"],"import React from 'react';\nimport { animated, useTransition } from 'react-spring';\nimport './welcome.css';\n\nexport default function Welcome(props) {\n  const fadeInOut = useTransition(props.visible, null, {\n    from: { opacity: 0 },\n    enter: { opacity: 1 },\n    leave: { opacity: 0 },\n    delay: 500,\n    config: { duration: 800 },\n  });\n\n  return fadeInOut.map(({ item, key, props: fadeInOutAnimation }) => {\n    return (\n      item && (\n        <animated.div style={fadeInOutAnimation} id=\"welcome\" key={key}>\n          <div id=\"welcome-header\"> Flow Animator</div>\n          <br />\n          <div id=\"welcome-text\">\n            Gain a new perspective on your professional workflows in Jira\n            (product development, service desk, incident management management,\n            or whatever you may be using Jira for) by watching an animation of\n            your issues flowing through the workflow statuses over time.\n          </div>\n        </animated.div>\n      )\n    );\n  });\n}\n","/Users/fredrik/dev/flowanimator/client/src/jira.js",["129"],"/**\n * @module src/jira\n * @description Contains functions for retrieving\n * [boards]{@link module:src/jira#getBoardsFromJira},\n * [board configurations]{@link module:src/jira#getBoardFromJira},\n *and [issues]{@link module:src/jira#getIssuesFromJira}  from the Jira REST API.\n */\n\n/**\n * Namespace encapsulating the functions\n * [getBoardsFromJira]{@link module:src/jira#getBoardsFromJira},\n * [getBoardFromJira]{@link module:src/jira#getBoardFromJira} and\n * [getIssuesFromJira]{@link module:src/jira#getIssuesFromJira}\n */\n\n/**\n * @method getBoardsFromJira\n * @instance\n * @description Retrieve from the Jira REST API the list of Jira boards that\n * the user has access to.\n * @param serverUrl Url to the Jira server (including possible cors proxy)\n * given by the user\n * @param id User id for logging to the Jira server, given by user\n * @param token Password or API token for logging to the Jira server, given by user\n */\nexport const getBoardsFromJira = (\n  serverUrl,\n  id,\n  token,\n  corsProxy,\n  localCorsProxyPort\n) => {\n  const BOARDS_PATH = '/rest/agile/1.0/board';\n  const boardsUrl = serverUrl + BOARDS_PATH;\n  // const boardsPromise = fetchFromJira(boardsUrl, id, token, {});\n\n  const parameters = {\n    startAt: 0,\n    maxResults: 500,\n  };\n\n  const boardsPromise = recursiveFetchFromJira(\n    boardsUrl,\n    id,\n    token,\n    parameters,\n    0, // startAt\n    'values', // fieldName\n    [], // values\n    corsProxy,\n    localCorsProxyPort\n  );\n\n  return boardsPromise;\n};\n\n/**\n * @method getProjectDataFromJira\n * @instance\n * @description Retrieve from the Jira REST API board information and isses\n *  for a given board that the user has access to.\n * @param serverUrl Url to the Jira server (including possible cors proxy)\n * given by the user\n * @param id User id for logging to the Jira server, given by user\n * @param token Password or API token for logging to the Jira server, given by user\n * @param boardId Id of the Jira board that the user selected to retrieve data for\n */\nexport const getProjectDataFromJira = (\n  serverUrl,\n  id,\n  token,\n  boardId,\n  corsProxy,\n  localCorsProxyPort\n) => {\n  return new Promise((resolve, reject) => {\n    const projectData = { serverUrl: serverUrl };\n    getBoardFromJira(\n      serverUrl,\n      id,\n      token,\n      boardId,\n      corsProxy,\n      localCorsProxyPort\n    ).then(boardConf => {\n      projectData.boardConf = boardConf;\n      getIssuesFromJira(\n        serverUrl,\n        id,\n        token,\n        boardConf.filter.id,\n        corsProxy,\n        localCorsProxyPort\n      ).then(issues => {\n        projectData.issues = issues;\n        resolve(projectData);\n      });\n    });\n  });\n};\n\n/**\n * @method getBoardFromJira\n * @instance\n * @description Retrieve from the Jira REST API the configuration of the\n * board defined by the boardId parameter\n * @param serverUrl Url to the Jira server (including possible cors proxy)\n * given by the user\n * @param id User id for logging to the Jira server, given by user\n * @param token Password or API token for logging to the Jira server, given by user\n * @param boardId Jira id of the board whose configuration is to be retrieved\n */\nfunction getBoardFromJira(\n  serverUrl,\n  id,\n  token,\n  boardId,\n  corsProxy,\n  localCorsProxyPort\n) {\n  const boardConfigurationUrl =\n    serverUrl + '/rest/agile/1.0/board/' + boardId + '/configuration';\n  // const boardConfPromise = fetchFromJira(boardConfigurationUrl, id, token, {});\n  const boardConfPromise = fetchFromServer(\n    boardConfigurationUrl,\n    id,\n    token,\n    {},\n    corsProxy,\n    localCorsProxyPort\n  );\n\n  return boardConfPromise;\n}\n\n/**\n * @method getIssuesFromJira\n * @instance\n * @description Retrieve from the Jira REST API the details of the issues\n * matching the filter specified by the filterId parameter\n * @param serverUrl Url to the Jira server (including possible cors proxy)\n * given by the user\n * @param id User id for logging to the Jira server, given by user\n * @param token Password or API token for logging to the Jira server, given by user\n * @param filterId Jira id of the filter to be used for querying issues\n */\nfunction getIssuesFromJira(\n  serverUrl,\n  id,\n  token,\n  filterID,\n  corsProxy,\n  localCorsProxyPort\n) {\n  const issuesUrl = serverUrl + '/rest/api/2/search';\n\n  const parameters = {\n    jql: 'filter = ' + filterID,\n    startAt: 0,\n    maxResults: 500,\n    fields: [\n      'key',\n      'summary',\n      'issuetype',\n      'created',\n      'status',\n      'creator',\n      'labels',\n      'resolutiondate',\n    ],\n    expand: 'changelog',\n  };\n\n  const issuesPromise = recursiveFetchFromJira(\n    issuesUrl,\n    id,\n    token,\n    parameters,\n    0, // startAt\n    'issues', // fieldName\n    [], // values\n    corsProxy,\n    localCorsProxyPort\n  );\n\n  return issuesPromise;\n}\n\n/****************************************************************************\n                          recursiveFetchFromJira\n ****************************************************************************/\n\n/**\n * @method recursiveFetchFromJira\n * @description Recursive function making multiple requests to the Jira REST API\n * to fetch a complete list of items in situations where each request only\n * retrieves a subset of all items.\n * @param ul Url to the Jira REST API resource (including possible cors proxy url)\n * @param id User id for logging to the Jira server, given by user\n * @param token Password or API token for logging to the Jira server, given by user\n * @param parameters Possible parameters to be included in the HTTP request\n * @param startAt The index of the first item to be retrieved\n * @param fieldName The name of the field in the response JSON that contains the\n * list of the items that we want to retrieve. This can be different for\n * different API resources, e.g. when retrieving boards, the field is called\n * \"values\" but when retrieving issues, the field is called \"issues\".\n * @param values Holds the list of items retrieved through the calls to the API.\n * This list is passed as a parameter and added to in each subsequent API call.\n */\nfunction recursiveFetchFromJira(\n  url,\n  id,\n  token,\n  parameters,\n  startAt,\n  fieldName,\n  values,\n  corsProxy,\n  localCorsProxyPort\n) {\n  parameters['startAt'] = startAt;\n\n  // const valuesPromise = fetchFromJira(url, id, token, parameters).then(\n  const valuesPromise = fetchFromServer(\n    url,\n    id,\n    token,\n    parameters,\n    corsProxy,\n    localCorsProxyPort\n  ).then(response => {\n    if (response[fieldName].length > 0) {\n      return recursiveFetchFromJira(\n        url,\n        id,\n        token,\n        parameters,\n        response['startAt'] + response[fieldName].length,\n        fieldName,\n        values.concat(response[fieldName]),\n        corsProxy,\n        localCorsProxyPort\n      );\n    } else {\n      return values;\n    }\n  });\n  return valuesPromise;\n}\n\n/****************************************************************************\n                              fetchFromJira\n ****************************************************************************/\n\n/**\n * @method fetchFromJira\n * @description Makes a call to the given Jira REST API and passes on the\n * response to the calling function in the form of a promise\n * @param ul Url to the Jira REST API resource (including possible cors proxy url)\n * @param id User id for logging to the Jira server, given by user\n * @param token Password or API token for logging to the Jira server, given by user\n * @param parameters Possible parameters to be included in the HTTP request\n */\n/*\nfunction fetchFromJira(url, id, token, parameters) {\n  const authorizationString = 'Basic ' + btoa(id + ':' + token);\n  const options = {\n    method: 'GET',\n    headers: {\n      Authorization: authorizationString,\n      'Content-Type': 'application/json',\n    },\n  };\n\n  if (parameters) {\n    url = url + '?' + serialize(parameters);\n  }\n\n  const resultPromise = fetch(url, options)\n    .then(response => {\n      if (response.ok) {\n        return response.json();\n      } else {\n        throw new Error(response.status);\n      }\n    })\n    .catch(error => {\n      alert(error);\n    });\n  return resultPromise;\n}*\n\n/**\n * @function serialize\n * @description Converts a JavaScript object with HTTP request parameters into\n * a serialized string that can be appended to the url\n * @param obj JavaScript object with HTTP request parameters to be serialized\n */\nfunction serialize(obj) {\n  let str = Object.keys(obj)\n    .reduce((a, k) => {\n      a.push(k + '=' + encodeURIComponent(obj[k]));\n      return a;\n    }, [])\n    .join('&');\n  return str;\n}\n\n/****************************************************************************\n                              fetchFromServer\n ****************************************************************************/\n\n/**\n * @method fetchFromServer\n * @description Makes a call to the given Jira REST API through a proxy on the\n * local node.js server and passes on the\n * response to the calling function in the form of a promise\n * @param ul Url to the Jira REST API resource (including possible cors proxy url)\n * @param id User id for logging to the Jira server, given by user\n * @param token Password or API token for logging to the Jira server, given by user\n * @param parameters Possible parameters to be included in the HTTP request\n */\n\nfunction fetchFromServer(\n  jiraUrl,\n  jiraId,\n  jiraToken,\n  jiraParameters,\n  corsProxy,\n  localCorsProxyPort\n) {\n  let serverUrl = '';\n  const options = {\n    method: 'GET',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  };\n\n  if (corsProxy === 'heroku') {\n    const parameters = {\n      url: jiraUrl,\n      id: jiraId,\n      token: jiraToken,\n      ...jiraParameters,\n    };\n    serverUrl = 'jira?' + serialize(parameters);\n  } else {\n    const authorizationString = 'Basic ' + btoa(jiraId + ':' + jiraToken);\n    options.headers.Authorization = authorizationString;\n    serverUrl = jiraUrl;\n    if (corsProxy === 'local') {\n      serverUrl = 'http://127.0.0.1:' + localCorsProxyPort + '/' + serverUrl;\n    }\n    if (jiraParameters) {\n      serverUrl = serverUrl + '?' + serialize(jiraParameters);\n    }\n  }\n\n  const resultPromise = fetch(serverUrl, options)\n    .then(response => {\n      if (response.ok) {\n        return response.json();\n      } else {\n        throw new Error(response.status);\n      }\n    })\n    .catch(error => {\n      alert(error);\n    });\n  return resultPromise;\n}\n\nexport function getBoardsUrl(url, boardName) {\n  const parameters = {\n    name: boardName,\n  };\n\n  return (\n    url.replace(/\\/$/, '') + '/rest/agile/1.0/board/?' + serialize(parameters)\n  );\n}\n\nexport function getIssuesUrl(url, filterId, maxResults, page) {\n  const parameters = {\n    jql: 'filter=' + filterId,\n    startAt: (page - 1) * maxResults,\n    maxResults: maxResults,\n    fields: [\n      'key',\n      'summary',\n      'issuetype',\n      'created',\n      'status',\n      'creator',\n      'labels',\n      'resolutiondate',\n    ],\n    expand: 'changelog',\n  };\n\n  return url.replace(/\\/$/, '') + '/rest/api/2/search?' + serialize(parameters);\n}\n","/Users/fredrik/dev/flowanimator/client/src/controls.js",["130"],"import React, {\n  useState,\n  useEffect,\n  createRef,\n  isValidElement,\n  cloneElement,\n  useCallback,\n} from 'react';\nimport CssSpinner from './css-spinner.js';\nimport { useSpring, animated, useTransition } from 'react-spring';\nimport { rgba } from 'polished';\n\nexport function RadioGroup(props) {\n  const [focused, setFocused] = useState(false);\n  const [hover, setHover] = useState(false);\n  const [wrapperRef] = useState(createRef());\n\n  const updateFocus = () => {\n    const wrapperDivFocused = document.activeElement.id === props.id;\n    const radioButtonFocused = document.activeElement.name === props.name;\n    setFocused(wrapperDivFocused || radioButtonFocused);\n  };\n\n  const handleValueChange = event => {\n    props.updateValue(event.target.value);\n  };\n\n  const handleKeyDown = event => {\n    if (event.keyCode >= 37 && event.keyCode <= 40) {\n      let movement;\n      switch (event.keyCode) {\n        case 37: // left\n        case 38: // up\n          movement = -1;\n          break;\n        case 39: // right\n        case 40: // down\n          movement = 1;\n          break;\n        default:\n      }\n\n      const currentSelectionIndex = props.choices.indexOf(\n        props.choices.find(choice => choice.value === props.value)\n      );\n      // -1 if no value selected\n\n      const newSelectionIndex = Math.min(\n        Math.max(currentSelectionIndex + movement, 0),\n        props.choices.length - 1\n      );\n\n      const newValue = props.choices[newSelectionIndex].value;\n\n      props.updateValue(newValue);\n    }\n  };\n\n  const radioGroupStyle = {\n    padding: '10px 0',\n    outline: 'none',\n    border: 'none',\n  };\n\n  const labelFontColorStyle = focused\n    ? { color: '#1FA9C1', fontWeight: 'bold' }\n    : {};\n\n  const labelStyle = {\n    display: 'block',\n    fontSize: '0.9em',\n    padding: '0 0 10px 0 ',\n    ...labelFontColorStyle,\n  };\n\n  const radioButtonsStyle = {\n    padding: '0 0 10px 0 ',\n  };\n\n  return (\n    <div\n      tabIndex={props.tabIndex}\n      ref={wrapperRef}\n      style={radioGroupStyle}\n      className={'radio-group'}\n      id={props.id}\n      onMouseEnter={() => {\n        setHover(true);\n      }}\n      onMouseLeave={() => {\n        setHover(false);\n      }}\n      onKeyDown={handleKeyDown}\n      onFocus={updateFocus}\n      onBlur={updateFocus}\n    >\n      <label style={labelStyle}>{props.label}</label>\n      <div style={radioButtonsStyle}>\n        {props.choices.map(choice => (\n          <RadioButton\n            choice={choice}\n            key={choice.value}\n            name={props.name}\n            onChange={handleValueChange}\n            checked={props.value === choice.value}\n            wrapperRef={wrapperRef}\n          />\n        ))}\n      </div>\n      <FocusLine hover={hover} focused={focused} />\n    </div>\n  );\n}\n\nfunction RadioButton(props) {\n  const inputStyle = {\n    width: '30px',\n    margin: '0px 0px 0px 0px',\n    display: 'inline-block',\n  };\n\n  const labelStyle = {\n    padding: '0 5px 0 0',\n  };\n\n  const handleFocus = () => {\n    if (props.wrapperRef.current) {\n      props.wrapperRef.current.focus();\n    }\n  };\n\n  return (\n    <label htmlFor={props.choice.value} style={labelStyle}>\n      <input\n        style={inputStyle}\n        type=\"radio\"\n        id={props.choice.value}\n        name={props.name}\n        value={props.choice.value}\n        className=\"corsRadio\"\n        checked={props.checked}\n        onFocus={handleFocus}\n        onChange={props.onChange}\n      />\n      <span>{props.choice.label}</span>\n    </label>\n  );\n}\n\nexport function TextInput(props) {\n  const [focused, setFocused] = useState(false);\n  const [hover, setHover] = useState(false);\n\n  const divStyle = {\n    position: 'relative',\n    padding: '30px 0 10px 0',\n  };\n\n  const labelFontColorStyle = focused ? { color: '#1FA9C1' } : {};\n\n  const labelBaseStyle = {\n    position: 'absolute',\n    left: '0px',\n    margin: '0 auto',\n    ...labelFontColorStyle,\n  };\n\n  const labelLoweredStyle = {\n    ...labelBaseStyle,\n    top: '29px',\n    fontSize: '1.2em',\n    transition: 'all 0.1s ease-in-out',\n  };\n\n  const labelRaisedStyle = {\n    ...labelBaseStyle,\n    top: '13px',\n    fontSize: '0.9em',\n    fontWeight: 'bold',\n    transition: 'all 0.2s ease-in-out',\n  };\n\n  const labelRaised = focused || props.value !== '';\n\n  const labelStyle = labelRaised ? labelRaisedStyle : labelLoweredStyle;\n\n  const inputStyle = {\n    position: 'relative',\n    top: '0px',\n    background: 'transparent',\n    padding: '0 0 4px 0',\n    height: '20px',\n    width: '100%',\n    fontSize: '1.2em',\n    textIndent: '0px',\n    zIndex: 11,\n    outline: 'none',\n    border: 'none',\n  };\n\n  return (\n    <div className=\"text-input\" style={{ ...divStyle, ...props.style }}>\n      <input\n        tabIndex={props.tabIndex}\n        type={props.type}\n        id={props.id}\n        name={props.name}\n        required={props.required}\n        value={props.value}\n        autoComplete={props.autoComplete}\n        style={inputStyle}\n        placeholder=\"\"\n        onChange={props.onChange}\n        onKeyDown={props.onKeyDown}\n        onFocus={event => {\n          setFocused(true);\n          if (props.onFocus) props.onFocus(event);\n        }}\n        onBlur={event => {\n          setFocused(false);\n          if (props.onBlur) props.onBlur(event);\n        }}\n        onMouseEnter={event => {\n          setHover(true);\n          if (props.onMouseEnter) props.onMouseEnter(event);\n        }}\n        onMouseLeave={event => {\n          setHover(false);\n          if (props.onMouseLeave) props.onMouseLeave(event);\n        }}\n      />\n      <label htmlFor={props.name} style={labelStyle}>\n        {focused || props.value !== ''\n          ? props.label\n          : props.placeholder || props.label}\n      </label>\n      <FocusLine hover={hover} focused={focused} />\n    </div>\n  );\n}\n\nfunction FocusLine(props) {\n  const lineBaseStyle = {\n    position: 'relative',\n    width: '100%',\n    height: '3px',\n    border: 'none',\n    borderRadius: '1px',\n  };\n\n  const lineHoverStyle = props.hover\n    ? {\n        opacity: 1,\n        height: '3px',\n      }\n    : {\n        opacity: 0.6,\n      };\n\n  const unfocusedLineStyle = {\n    ...lineBaseStyle,\n    ...lineHoverStyle,\n    backgroundColor: '#bbb',\n  };\n\n  const focusedLineHiddenStyle = props.focused ? {} : { width: '0px' };\n\n  const focusedLineStyle = {\n    ...lineBaseStyle,\n    ...focusedLineHiddenStyle,\n    top: '-3px',\n    height: '3px',\n    backgroundColor: '#25c0dc',\n    transition: 'all 0.2s ease-in-out',\n  };\n\n  return (\n    <div>\n      <div style={unfocusedLineStyle} />\n      <div style={focusedLineStyle} />\n    </div>\n  );\n}\n\nexport function TabbedPanels(props) {\n  const [tabBarFocused, setTabBarFocused] = useState(false);\n  const [selectedTab, setSelectedTab] = useState(0);\n\n  const tabBarId = props.id + '-tabBar';\n\n  const handleKeyDown = event => {\n    if (event.keyCode >= 37 && event.keyCode <= 40) {\n      let movement;\n      switch (event.keyCode) {\n        case 37: // left\n        case 38: // up\n          movement = -1;\n          break;\n        case 39: // right\n        case 40: // down\n          movement = 1;\n          break;\n        default:\n      }\n\n      const newSelectionIndex = Math.min(\n        Math.max(selectedTab + movement, 0),\n        props.tabs.length - 1\n      );\n      setSelectedTab(newSelectionIndex);\n    }\n  };\n\n  // https://stackoverflow.com/questions/32370994/how-to-pass-props-to-this-props-children\n\n  const tabPanels = props.children.map((tabPanel, index) => {\n    // Checking isValidElement is the safe way and avoids a TS error too.\n\n    if (isValidElement(tabPanel)) {\n      const visible = index === selectedTab;\n      return cloneElement(tabPanel, {\n        visible: visible,\n        key: index,\n      });\n    }\n    return tabPanel;\n  });\n\n  const tabbedPanelsStyle = {\n    display: 'flex',\n    flexDirection: 'column',\n  };\n\n  const tabBarStyle = {\n    width: '100%',\n    flex: '0 0 auto',\n    display: 'flex',\n    flexFlow: 'row nowrap',\n    outline: 'none',\n  };\n\n  return (\n    <div className=\"tabbed-panels\" style={tabbedPanelsStyle}>\n      <div\n        id={tabBarId}\n        className=\"tab-bar\"\n        style={tabBarStyle}\n        tabIndex={props.tabIndex}\n        onKeyDown={handleKeyDown}\n        onFocus={() => {\n          setTabBarFocused(true);\n        }}\n        onBlur={() => {\n          setTabBarFocused(false);\n        }}\n      >\n        {props.tabs.map((tab, index) => (\n          <Tab\n            label={tab}\n            key={index}\n            index={index}\n            selected={selectedTab === index}\n            setSelectedTab={setSelectedTab}\n            tabBarFocused={tabBarFocused}\n          />\n        ))}\n      </div>\n      {tabPanels}\n    </div>\n  );\n}\n\nfunction Tab(props) {\n  const [hover, setHover] = useState(false);\n\n  const tabBarFocusedStyle = props.tabBarFocused\n    ? {\n        color: '#1FA9C1',\n        borderColor: '#25c0dc',\n      }\n    : {};\n\n  const tabHoverStyle =\n    hover && !props.selected\n      ? {\n          fontWeight: 'bold',\n          letterSpacing: '0px',\n        }\n      : {};\n\n  const tabSelectedStyle = props.selected\n    ? {\n        fontWeight: 'bold',\n        letterSpacing: '0px',\n        borderColor: '#ccc',\n        ...tabBarFocusedStyle,\n      }\n    : {};\n\n  const tabStyle = {\n    flex: '0 0 auto',\n    width: '100px',\n    cursor: 'pointer',\n    letterSpacing: '0.5 px',\n    borderBottom: 'solid',\n    borderColor: '#eee',\n    textAlign: 'center',\n    ...tabHoverStyle,\n    ...tabSelectedStyle,\n  };\n\n  return (\n    <div\n      id={'tab' + props.index}\n      key={props.index}\n      style={tabStyle}\n      onMouseDown={() => {\n        props.setSelectedTab(props.index);\n      }}\n      onMouseEnter={() => {\n        setHover(true);\n      }}\n      onMouseLeave={() => {\n        setHover(false);\n      }}\n    >\n      {props.label}\n    </div>\n  );\n}\n\nexport function TabPanel(props) {\n  const tabPanelStyle = { flex: '1 1 auto' };\n\n  if (props.visible) {\n    return (\n      <div id={props.id} style={tabPanelStyle} className={'tab-panel'}>\n        {props.children}\n      </div>\n    );\n  } else {\n    return null;\n  }\n}\n\nexport function MultiPageForm(props) {\n  const [selectedPage, setSelectedPage] = useState(0);\n\n  const scrollPage = movement => {\n    const newSelectedPage = Math.min(\n      Math.max(selectedPage + movement, 0),\n      props.children.length - 1\n    );\n    if (newSelectedPage !== selectedPage) {\n      setSelectedPage(newSelectedPage);\n    }\n  };\n\n  const children = props.children.map((child, index) => {\n    // Checking isValidElement is the safe way and avoids a TS error too.\n    if (isValidElement(child)) {\n      const visible = index === selectedPage;\n      return cloneElement(child, {\n        visible: visible,\n        key: index,\n        scrollPage: scrollPage,\n      });\n    }\n    return children;\n  });\n\n  return <div>{children}</div>;\n}\n\nexport function FormPage(props) {\n  const [maxTabIndex, setMaxTabIndex] = useState(-1);\n  useEffect(() => {\n    let newMaxTabIndex = -1;\n    React.Children.toArray(props.children).forEach(child => {\n      if (child.props && child.props.tabIndex > maxTabIndex) {\n        newMaxTabIndex = child.props.tabIndex;\n      }\n    });\n    setMaxTabIndex(newMaxTabIndex);\n  }, []); // eslint-disable react-hooks/exhaustive-deps\n\n  const formStyle = {\n    display: 'flex',\n    flexDirection: 'column',\n    justifyContent: 'space-between',\n  };\n\n  const formHeaderStyle = {};\n\n  const formContentStyle = {\n    flex: '10 10 auto',\n    display: 'flex',\n    flexDirection: 'column',\n    justifyContent: 'flex-start',\n  };\n\n  const buttonBarStyle = {\n    display: 'flex',\n    flexDirection: 'row-reverse',\n    marginTop: '20px',\n  };\n\n  const buttonStyle = {\n    position: 'relative',\n    boxSizing: 'border-box',\n    borderStyle: 'solid',\n    outline: 'none',\n    borderWidth: '3px',\n    fontSize: '1.2em',\n    cursor: 'pointer',\n    width: '150px',\n    height: '50px',\n    borderRadius: '15px',\n  };\n\n  const forwardButton = ({ forwardButton, tabIndex }) => {\n    if (forwardButton) {\n      const successCallback = () => {\n        props.scrollPage(1);\n      };\n\n      const clickForward = event => {\n        event.preventDefault();\n        if (\n          (forwardButton.onClick && forwardButton.onClick(successCallback)) ||\n          !forwardButton.onClick\n        ) {\n          props.scrollPage(1);\n        }\n      };\n\n      const forwardButtonStyle = {\n        ...buttonStyle,\n        margin: '0px 0px 0px 8px',\n      };\n\n      return (\n        <button\n          tabIndex={tabIndex}\n          className=\"primary-button\"\n          style={forwardButtonStyle}\n          onClick={clickForward}\n          disabled={forwardButton.disabled}\n        >\n          {forwardButton.label}\n          <CssSpinner visible={forwardButton.showSpinner} />\n        </button>\n      );\n    }\n  };\n\n  const backwardButton = ({ backwardButton, tabIndex }) => {\n    const clickBackward = event => {\n      event.preventDefault();\n      if (\n        (backwardButton.onClick && backwardButton.onClick()) ||\n        !backwardButton.onClick\n      ) {\n        props.scrollPage(-1);\n      }\n    };\n\n    const backwardButtonStyle = {\n      ...buttonStyle,\n    };\n\n    if (backwardButton) {\n      return (\n        <button\n          tabIndex={tabIndex}\n          className=\"secondary-button\"\n          style={backwardButtonStyle}\n          onClick={clickBackward}\n          disabled={backwardButton.disabled}\n        >\n          {backwardButton.label}\n        </button>\n      );\n    }\n  };\n\n  if (props.visible) {\n    return (\n      <form\n        style={formStyle}\n        className={'form-page'}\n        onSubmit={event => {\n          event.preventDefault();\n        }}\n      >\n        <div style={formHeaderStyle} className=\"form-header\">\n          <h1>{props.header}</h1>\n          {props.subheader ? <h2>{props.subheader}</h2> : ''}\n        </div>\n        <div style={formContentStyle} className=\"form-content\">\n          {props.children}\n        </div>\n        <div style={buttonBarStyle} className=\"form-button-bar\">\n          {forwardButton({\n            ...props,\n            tabIndex: maxTabIndex + 1,\n          })}\n          {backwardButton({ ...props, tabIndex: maxTabIndex + 2 })}\n        </div>\n      </form>\n    );\n  } else {\n    return null;\n  }\n}\n\nexport function Modal(props) {\n  const [resetAnimation, setResetAnimation] = useState(false);\n  const [modalRef] = useState(React.createRef());\n  const rollUpAnimation = useSpring({\n    config: { mass: 2, tension: 125, friction: 22 },\n    top: 0,\n    from: { top: 160 },\n    reset: resetAnimation,\n    onStart: () => {\n      setResetAnimation(false);\n    },\n  });\n\n  useEffect(() => {\n    if (props.visible) {\n      setResetAnimation(true);\n    }\n  }, [props.visible]);\n\n  const handleKeyDown = useCallback(\n    event => {\n      const { handleModalClose } = props;\n      const keys = {\n        // Esc\n        27: () => {\n          props.closeModal();\n        },\n        // Tab\n        9: () => {\n          // Enforce focus trap\n\n          if (modalRef.current) {\n            const focusableModalElements = Array.from(\n              modalRef.current.querySelectorAll('[tabindex]')\n            )\n              .filter(elem => !elem.disabled)\n              .sort((elemA, elemB) => {\n                return elemA.tabIndex - elemB.tabIndex;\n              });\n\n            const currentSelectedElementIndex = focusableModalElements.indexOf(\n              document.activeElement\n            );\n\n            const movement = event.shiftKey ? -1 : 1;\n            var nextSelectedElementIndex =\n              currentSelectedElementIndex + movement;\n            if (\n              nextSelectedElementIndex < 0 ||\n              nextSelectedElementIndex >= focusableModalElements.length\n            ) {\n              nextSelectedElementIndex = event.shiftKey\n                ? focusableModalElements.length - 1\n                : 0;\n            }\n            const nextSelectedElement =\n              focusableModalElements[nextSelectedElementIndex];\n            nextSelectedElement.focus();\n            event.preventDefault();\n          }\n        },\n      };\n\n      if (keys[event.keyCode]) {\n        keys[event.keyCode]();\n      }\n    },\n    [props, modalRef]\n  );\n\n  useEffect(() => {\n    window.addEventListener('keydown', handleKeyDown, false);\n\n    return () => {\n      if (window.RemoveEventListener) {\n        window.RemoveEventListener('keydown', handleKeyDown, false);\n      }\n    };\n  }, [handleKeyDown]);\n\n  const modalBackgroundStyle = {\n    display: 'flex',\n    overflow: 'hidden',\n    position: 'fixed',\n    zIndex: 100,\n    justifyContent: 'center',\n    alignItems: 'center',\n    left: 0,\n    top: 0,\n    width: '100%',\n    height: '100%',\n    backgroundColor: rgba(0, 0, 0, 0.6),\n  };\n\n  const modalWindowStyle = {\n    display: 'flex',\n    flexDirection: 'column',\n    justifyContent: 'space-between',\n    position: 'relative',\n    borderRadius: '25px',\n  };\n\n  const closeButtonStyle = {\n    margin: 0,\n    padding: 0,\n    position: 'absolute',\n    top: '3px',\n    right: '12px',\n    fontSize: '28px',\n    fontWeight: 'bold',\n    opacity: 0.6,\n    backgroundColor: rgba(1, 1, 1, 0),\n    border: 'none',\n  };\n\n  const fadeInOut = useTransition(props.visible, null, {\n    from: { opacity: 0 },\n    enter: { opacity: 1 },\n    leave: { opacity: 0 },\n  });\n\n  return fadeInOut.map(({ item, key, props: fadeInOutAnimation }) => {\n    return (\n      item && (\n        <animated.div\n          style={{ ...modalBackgroundStyle, ...fadeInOutAnimation }}\n          id={props.id}\n          key={key}\n          ref={modalRef}\n          className=\"modal-background\"\n        >\n          <animated.div\n            style={{ ...modalWindowStyle, ...rollUpAnimation }}\n            className=\"modal-window\"\n          >\n            <div className=\"modal-header\">\n              <HoverFocusedButton\n                defaultStyle={closeButtonStyle}\n                hoverStyle={{ opacity: 1 }}\n                focusedStyle={{ opacity: 1 }}\n                className=\"close-button\"\n                onClick={() => {\n                  props.closeModal();\n                }}\n              >\n                &times;\n              </HoverFocusedButton>\n            </div>\n            <div className=\"modal-body\">{props.children}</div>\n          </animated.div>\n        </animated.div>\n      )\n    );\n  });\n}\n\nfunction HoverFocusedButton(props) {\n  const [hover, setHover] = useState(false);\n  const [focused, setFocused] = useState(false);\n\n  const { defaultStyle, hoverStyle, focusedStyle, ...otherProps } = props;\n  const appliedHoverStyle = hover ? hoverStyle : {};\n  const appliedFocusedStyle = focused ? focusedStyle : {};\n\n  const buttonStyle = {\n    ...defaultStyle,\n    ...appliedHoverStyle,\n    ...appliedFocusedStyle,\n  };\n\n  return (\n    <button\n      {...otherProps}\n      style={buttonStyle}\n      onMouseEnter={() => setHover(true)}\n      onMouseLeave={() => setHover(false)}\n      onFocus={() => setFocused(true)}\n      onBlur={() => setFocused(false)}\n    >\n      {props.children}\n    </button>\n  );\n}\n","/Users/fredrik/dev/flowanimator/client/src/animation-data.js",["131"],"/**\n * @file src/animation.js\n * @description Defines the {@link Animation} class that provides functionality for reading\n * workflow, issue and transition data from a source (Jira server, possibly\n * other sources in the future) and for generating the animation of the\n * issues and their transitions\n */\n//\nimport { Transition } from './transition.js';\nimport { ColumnCollection, UNCREATED_COLUMN_ID } from './column.js';\nimport { StoryCollection } from './story.js';\nimport { utils } from './utils.js';\n\n// TODO: Be consistent in whether or not unit of time (_IN_MS) is appended to variable and constant names\n\nconst TRANSITION_DURATION = 200;\nconst DROP_DURATION = 100;\nconst DROP_DELAY = 1;\nconst CALENDAR_DAY_IN_MS = 86400000;\nconst TRANSITIONS_PER_DAY = 2;\nconst DAY_IN_ANIMATION_TIME = TRANSITION_DURATION * TRANSITIONS_PER_DAY;\nexport const TRANSITION_IN_CALENDAR_TIME =\n  CALENDAR_DAY_IN_MS / TRANSITIONS_PER_DAY;\nconst AGE_COLORING_MAX_AGE = 30 * CALENDAR_DAY_IN_MS;\nexport const MOVE_END_MARGIN = TRANSITION_DURATION + 10;\n// const ATTRIBUTE_FIELDS_IN_IMPORT_FILE = 3; // The number of story attribute fields in the Jira import file before the transitions start\n// const DELIMITER = ';';\n\n/**\n * @memberof Animation\n * @inner\n * @method\n * @description Converts real calendar date/time values (in microseconds) to\n * their corresponding time values (in microseconds) on the animation timeline.\n * @param calendarDays Amount of real-life date/time, expressed in Unix Epoch\n * milliseconds i.e. milliseconds since 1.1.1970\n */\nexport const calendarDaysToAnimationTime = calendarDays => {\n  return (calendarDays / CALENDAR_DAY_IN_MS) * DAY_IN_ANIMATION_TIME;\n};\n\n/**\n * @memberof Animation\n * @inner\n * @method\n * @description Converts a moment in ms on the animation timeline to the\n * corresponding real-life date/time in Unix Epoch  milliseconds\n * i.e. milliseconds since 1.1.1970\n * @param animationTime A moment in ms on the animation timeline\n */\nconst animationTimeToCalendarDays = animationTime => {\n  return (animationTime * CALENDAR_DAY_IN_MS) / DAY_IN_ANIMATION_TIME;\n};\n\nexport const AnimationData = {\n  getAnimationData: function(projectData) {\n    const { boardConf, issues, serverUrl } = projectData;\n    console.log('getAnimationData');\n    console.log(boardConf);\n    console.log(issues);\n    console.log(serverUrl);\n\n    const animUtils = {\n      AGE_COLORING_MAX_AGE: AGE_COLORING_MAX_AGE,\n      TRANSITION_DURATION: TRANSITION_DURATION,\n      calendarDaysToAnimationTime: calendarDaysToAnimationTime,\n    };\n\n    const columns = new ColumnCollection();\n    columns.addColumnsFromJira(boardConf.columnConfig.columns);\n    const stories = new StoryCollection(animUtils);\n    stories.addStoriesFromJira(issues, columns, serverUrl);\n\n    Transition.prototype.getFirstTransitionDate =\n      stories.transitions.getFirstTransitionDate;\n\n    const projectTimespan_initial = {\n      startDate: stories.transitions.getFirstTransitionDate(),\n      endDate:\n        stories.transitions.getLastTransitionDate() +\n        animationTimeToCalendarDays(TRANSITION_DURATION),\n    };\n\n    const animationDuration_initial =\n      calendarDaysToAnimationTime(stories.transitions.getTimespan()) +\n      TRANSITION_DURATION;\n\n    animUtils.lastTransitionDate = stories.transitions.getLastTransitionDate();\n\n    animUtils.calendarDateToAnimationTime = calendarDate => {\n      return calendarDaysToAnimationTime(\n        Math.max(\n          Math.min(calendarDate, stories.transitions.getLastTransitionDate()) -\n            stories.transitions.getFirstTransitionDate(),\n          0\n        )\n      );\n    };\n\n    const animationTimeToCalendarDate = animationTime => {\n      return (\n        stories.transitions.getFirstTransitionDate() +\n        animationTimeToCalendarDays(animationTime)\n      );\n    };\n\n    return {\n      columns: columns,\n      stories: stories,\n      projectTimespan_initial: projectTimespan_initial,\n      animationDuration_initial: animationDuration_initial,\n      animationTimeToCalendarDate: animationTimeToCalendarDate,\n    };\n  },\n\n  buildAnimation: function(\n    stories,\n    progressCallback,\n    completionCallback,\n    animationDuration_initial\n  ) {\n    // Calculate the coming duration of the animation (in milliseconds);\n    // this is an estimate that may still increase if there is \"congestion\"\n    // at the end of the animation that causes some transitions to be postponed\n    // beyond the original end of the project.\n\n    // Next, run the generation of the animation. This can take severa minutes,\n    // and we don't want the ui to be frozen during that time. Therefore, we\n    // will use a mechanism that yields control to the rest of the application\n    // after each round in the animation generation. This is based on using\n    // a) a Generator function\n    // b) an async version of setInterval, as proposed by Jason Yu in comments\n    // section of https://dev.to/akanksha_9560/why-not-to-use-setinterval--2na9\n\n    // First, instantiate the generator function that generates the animation step by step\n    const animationGenerator = AnimationGenerator(\n      stories,\n      animationDuration_initial\n    );\n    // Then, launch the async version of setInterval, which executes the next\n    // round of the generator function at each interval; between each\n    // execution, control gets yielded to the rest of the application\n    utils.setIntervalAsync(\n      // async function to be executed\n      async () => {\n        // Execute next round of the generator\n        return animationGenerator.next();\n      },\n      // Interval between executions\n      0,\n      // Progress Callback function called by setIntervalAsync after each iteration of the generator\n      progressCallback,\n      // Completion Callback function called by setIntervalAsync upon completion of the generator\n      completionCallback\n    );\n    // Launch the procedure to color the stories according to their age\n    generateColorAnimation();\n  },\n};\n\n/****************************************************************************\n                         AnimationGenerator\n ****************************************************************************/\n/**\n * @memberof Animation\n * @inner\n * @method AnimationGenerator\n * @description Generator function that generates the animation i.e. the\n * movements of the stories between the columns of the board, according to\n * the status transitions of the stories in the Jira project. The generator\n * function gets triggered by setIntervalAsync launched in **buildAnimation**\n * and generates the animation of the next status transition in the transitions\n * collection, after which it yields back the control to the rest of the application.\n * It then gets retriggered by setIntervalAsync and this continues until\n * the generator has generated the animation of each status transition in the\n * transitions collection. This way we avoid freezing the ui while the\n * animation generation is running.\n */\nfunction* AnimationGenerator(stories, animationDuration_initial) {\n  /* console.log('Starting AnimationGenerator'); */\n  let loadProgress = 0;\n  for (let transition of stories.transitions.getIterator()) {\n    // Determine where the transition should be positioned on the timeline.\n    // This is based on the time stamp of the transition relative to\n    // the entire timespan that the timeline represents.\n    // TODO rename DateTime to Date throughout project\n\n    const transitionStartOnTimeline = calendarDaysToAnimationTime(\n      transition.getTransitionStartDateTime() -\n        stories.transitions.getFirstTransitionDate()\n    );\n\n    const storyToMove = transition.story;\n\n    // The story's currently recorded column is the column from which the\n    // animation should start\n    const fromColumn = storyToMove.column;\n    // The transition's destination column is the column where the\n    // animation should end\n    const toColumn = transition.toColumn;\n    // The story's currently recorded vertical slot is the slot from which the\n    // animation should start\n    var fromSlot = storyToMove.verticalSlot;\n    // Remove the story from the list of stories in the column that it's\n    // moving out from\n    fromColumn.storiesInColumn.splice(fromSlot, 1);\n    // Add the story to the list of stories in the column that it's moving into\n    toColumn.storiesInColumn.push(storyToMove);\n    // Check which vertical slot of the new column the story landed in\n    const toSlot = toColumn.storiesInColumn.indexOf(storyToMove);\n    // Record on the story the new column that it moved into...\n    storyToMove.column = toColumn;\n    // ...as well as the new vertical slot; we will need these values again\n    // when we animate the next transition of this story.\n    storyToMove.verticalSlot = toSlot;\n\n    // Now, animate the transition:\n\n    // If this is the first transition of the story, we should do a few things\n    if (fromColumn.number === UNCREATED_COLUMN_ID) {\n      // First, set the starting slot equal to the destination slot since we\n      // want to make stories fly in horisontally in their first transition.\n      fromSlot = toSlot;\n    }\n\n    // Move the token from its current column & slot to the new ones\n    // storyToMove.token.elements\n\n    stories.moves.push(\n      storyToMove.addMove(\n        'move',\n        transitionStartOnTimeline,\n        TRANSITION_DURATION,\n        fromColumn,\n        toColumn,\n        fromSlot,\n        toSlot\n      )\n    );\n\n    // Record the ending time of this transition on the story; we will refer\n    // to this value later on if the story is getting dropped\n    storyToMove.previousAnimationFinish =\n      transitionStartOnTimeline + TRANSITION_DURATION;\n\n    // Next we shoud drop downwards any stories in the starting column that\n    // were above the story that moved out. However, there is no need to\n    // perform any drops on stories in the first invisible \"uncreated\" column,\n    // so drops are only to be performed if the column that the story moved\n    // out of is any other than the \"uncreated\" column.\n    if (fromColumn.number !== UNCREATED_COLUMN_ID) {\n      // Form a list of any stories at or above the slot of the story that just\n      // moved out\n      const storiesToDrop = fromColumn.storiesInColumn.slice(fromSlot);\n      storiesToDrop.forEach(storyToDrop => {\n        // The animation should start in the story's current vertical slot...\n        const dropFromSlot = storyToDrop.verticalSlot;\n        // ...and end in one slot below\n        const dropToSlot = storyToDrop.verticalSlot - 1;\n        // The drop animation should start a brief moment later than the\n        // main animation of the story that moved out and caused the drop. If\n        // the previous animation of the story being dropped hasn't yet\n        // finished by then, we should delay the start until the completion\n        // of this prior transition, which we recorded on the story when this\n        // transition was generated.\n        var dropStartOnTimeLine = Math.max(\n          transitionStartOnTimeline + DROP_DELAY,\n          storyToDrop.previousAnimationFinish\n        );\n\n        // We should only animate the drop if there is time for the drop\n        // animation to finish before the next out transition of the dropped\n        // story is to start. We therefore need to check the next transition\n        // of the story to be dropped (if any). Since the getNextTransition\n        // requires an iteration through the story's transitions, we only\n        // want to do it once, hence we cache the result in a local variable.\n        const nextTransitionOfDropStory = storyToDrop.getNextTransition(\n          transition\n        );\n        // Perform the drop if there is no next transition, or if the next\n        // transition starts only after the drop transition has finished.\n\n        if (\n          !nextTransitionOfDropStory ||\n          nextTransitionOfDropStory.getTransitionStartOnTimeline() >\n            dropStartOnTimeLine + DROP_DURATION\n        ) {\n          // Animate the drop.\n          stories.moves.push(\n            storyToDrop.addMove(\n              'drop',\n              dropStartOnTimeLine,\n              DROP_DURATION,\n              fromColumn,\n              fromColumn,\n              dropFromSlot,\n              dropToSlot\n            )\n          );\n        } else {\n          /* console.log('Conditions not fulfilled'); */\n          /* console.log(nextTransitionOfDropStory); */\n          /* console.log(nextTransitionOfDropStory.getTransitionStartOnTimeline()); */\n          /* console.log(dropStartOnTimeLine + DROP_DURATION); */\n          /* console.log(''); */\n        }\n        // Record the new vertical slot on the story.\n        storyToDrop.verticalSlot = dropToSlot;\n        // Also record the finishing time of the drop animation, as this\n        // will be needed in the case of subsequent drops of this story.\n        storyToDrop.previousAnimationFinish =\n          dropStartOnTimeLine + DROP_DURATION;\n      });\n    }\n\n    // Keep track of how far the animation has extended so far, in order to\n    // set the load bar accordingly.\n    // NB in the current version of this application, the transitions should\n    // get processed in an order where transitionStartOnTimeline\n    // of each transition is always larger than or equal to that of the\n    // previous transition, hence the use of the max function here should not\n    // actually be necessary anymore. However, it's still safer to keep it\n    // and the cost shouldn't be that high.\n\n    // console.log(loadProgress);\n    // console.log(transitionStartOnTimeline);\n    // console.log(TRANSITION_DURATION);\n\n    loadProgress = Math.max(\n      loadProgress,\n      transitionStartOnTimeline + TRANSITION_DURATION\n    );\n    /* console.log(loadProgress); */\n    const animationDuration = Math.max(animationDuration_initial, loadProgress);\n\n    const projectTimespan = {\n      startDate: stories.transitions.getFirstTransitionDate(),\n      endDate:\n        stories.transitions.getFirstTransitionDate() +\n        animationTimeToCalendarDays(animationDuration),\n    };\n\n    const yieldValue = {\n      projectTimespan_updated: projectTimespan,\n      animationDuration: animationDuration,\n      loadProgress: loadProgress,\n    };\n\n    // Yield control back to the calling function along with information\n    // about how far into the animation time the animation generation\n    // has proceeded.\n    yield yieldValue;\n  }\n\n  // Now all transitions have been animated so we should execute the return\n  // statement to indicate that the animation generation is complete, while\n  // also passing information about how long the animation eventually\n  // became. This may be longer than the initial estimate calculated in\n  // getAnimationData if there was \"congestion\" at the end of the animation\n  // that caused some animation(s) to be moved forward past the originally\n  // estimated end time.\n  /* console.log('Animation Generator completed'); */\n  return;\n}\n/****************************************************************************\n                      generateColorAnimation\n ****************************************************************************/\n/**\n * @memberof Animation\n * @inner\n * @method generateColorAnimation\n * @description Generate animation of the fill colors of the story tokens so that\n * the color of the token at any point of the animation indicates the age of\n * the story at that point in time.\n */\nfunction generateColorAnimation() {\n  /* console.log('Starting generateColorAnimation...'); */\n  // Iterate over all stories\n  /* console.log(stories); */\n  /* console.log(stories.getIterator()); */\n  // for (var story of stories.getIterator()) {\n  /* console.log('Picked up story ' + story.id); */\n  // The coloring should only start at the point when the story gets\n  // committed, i.e. moved into a column that indicates that the story\n  // has been selected to be worked on. (Ususally this is the second column,\n  // and for the time being we assume that this is always the case.) The date\n  // when the story was moved into the \"committed column\" got recorded in\n  // the contructor of the story and is available through .getCommittedDate().\n  // Not all stories have moved out of their initial columns, so we should\n  // first check for the presence of the committed date.\n  // if (story.getCommittedDate()) {\n  // // Color animation starts at the committed date...\n  // const animationStartDate = story.getCommittedDate();\n  // // ... and ends at the \"DoneDate\" when the story reaches the final column,\n  // // or no DoneDate is available, meaning that the story hasn't reached\n  // // the final column yet, then the color animation should last until the\n  // // end of the whole project being animated.\n  // const animationEndDate = story.getDoneDate()\n  //   ? story.getDoneDate()\n  //   : transitions.getLastTransitionDate();\n  // // Calculate how many days (in milliseconds) after the first transition\n  // // the story's color animation is starting\n  // const animationDateSpan =\n  //   animationStartDate - transitions.getFirstTransitionDate();\n  // // Convert this to animation time to get the right starting point on the\n  // // timeline. (NB the animationDateSpan value is used later on as well.)\n  // const colorAnimationStart = calendarDaysToAnimationTime(\n  //   animationDateSpan\n  // );\n  // // Calculate the number of calendar days (in milliseconds) that the\n  // // story's color animation spans and convert this to animation time.\n  // const colorAnimationLength = calendarDaysToAnimationTime(\n  //   animationEndDate - animationStartDate\n  // );\n  // // Define the final color value that the story should have at the\n  // // end of the animation. The color value is defined in terms of\n  // // the green and blue components in RGB since we are changing the color\n  // // of the stories from white to ever darkening shades of red by reducing\n  // // the green and blue values.\n  // const finalGreenAndBlueValue =\n  //   (1 - Math.min(animationDateSpan / AGE_COLORING_MAX_AGE, 1)) * 255;\n  // /* console.log('finalGreenAndBlueValue: ' + finalGreenAndBlueValue); */\n  // // Now generate the animation of the color towards its final value\n  // // story.token.circle\n  // //   .animate(colorAnimationLength, colorAnimationStart, 'absolute')\n  // //   .attr({\n  // //     fill: new SVG.Color({\n  // //       r: 255,\n  // //       g: finalGreenAndBlueValue,\n  // //       b: finalGreenAndBlueValue,\n  // //     }),\n  // //   });\n  // // Again, the timeline seems to start auto playing whenever new\n  // // animations are being added so the timeline should be paused again\n  // // unless we actually are in a playing mode already.\n  // // if (!ui.animationPlaying) { // no longer necessary\n  // //  timeline.pause();\n  // // }\n  // }\n  // }\n}\n","/Users/fredrik/dev/flowanimator/client/src/calendar-timeline.js",["132"],"import React, { memo } from 'react';\n\n/******************************************************************************\n                        CALENDAR TIMELINE\n ******************************************************************************/\n\nfunction CalendarTimeline(props) {\n  /* console.log('Render CalendarTimeline'); */\n  /* console.log(props); */\n  if (props.timespan) {\n    const startDate = new Date(props.timespan.startDate);\n    const endDate = new Date(props.timespan.endDate);\n\n    const CALENDAR_TIMELINE_TOP = 3;\n    const CALENDAR_TIMELINE_HEIGHT = 57;\n    const maxDayTicks = props.width / 25;\n    const maxMonthTicks = props.width / 30;\n    const maxYearTicks = props.width / 30;\n    const dt_margin = 6;\n\n    const dayLineHeight = 3;\n    const dayLabelHeight = 10;\n    const dayMarkerHeight = dayLineHeight + dt_margin + dayLabelHeight;\n    const monthLabelHeight = 12;\n\n    /*eslint no-extend-native: [\"error\", { \"exceptions\": [\"Date\"] }]*/\n    Date.prototype.getDays = function() {\n      return this.getTime() / (1000 * 60 * 60 * 24);\n    };\n\n    Date.prototype.addDays = function(days) {\n      // https://stackoverflow.com/questions/563406/add-days-to-javascript-date\n      var date = new Date(this.valueOf());\n      date.setDate(date.getDate() + days);\n      return date;\n    };\n\n    const daysInProject = endDate.getDays() - startDate.getDays();\n    const lines = [];\n    const labels = [];\n\n    var dayInterval = undefined;\n\n    if (daysInProject <= maxDayTicks) {\n      dayInterval = 1;\n    } else if (daysInProject / 2 <= maxDayTicks) {\n      dayInterval = 2;\n    } else if (daysInProject / 5 <= maxDayTicks) {\n      dayInterval = 5;\n    }\n\n    const plotDays = dayInterval !== undefined;\n\n    const monthsInProject =\n      (endDate.getFullYear() - startDate.getFullYear()) * 12 +\n      endDate.getMonth() -\n      startDate.getMonth();\n\n    var monthInterval = undefined;\n    if (monthsInProject === 0) {\n      monthInterval = undefined;\n    } else if (monthsInProject <= maxMonthTicks) {\n      monthInterval = 1;\n    } else if (monthsInProject / 2 <= maxMonthTicks) {\n      monthInterval = 2;\n    } else if (monthsInProject / 3 <= maxMonthTicks) {\n      monthInterval = 3;\n    } else if (monthsInProject / 6 <= maxMonthTicks) {\n      monthInterval = 6;\n    }\n    const plotMonths = monthInterval !== undefined;\n\n    const yearsInProject = endDate.getFullYear() - startDate.getFullYear();\n\n    var yearInterval = undefined;\n    if (yearsInProject === 0) {\n      yearInterval = undefined;\n    } else if (yearsInProject <= maxYearTicks) {\n      yearInterval = 1;\n    } else if (yearsInProject / 2 <= maxYearTicks) {\n      yearInterval = 2;\n    } else if (yearsInProject / 5 <= maxYearTicks) {\n      yearInterval = 5;\n    } else if (yearsInProject / 10 <= maxYearTicks) {\n      yearInterval = 10;\n    } // not going to support longer projects than this !!! :-D\n\n    let firstMonthToPlot = true;\n\n    for (var day = 0; day <= daysInProject; day++) {\n      const date = new Date(startDate.valueOf()).addDays(day);\n\n      const xCoord =\n        props.margin + Math.round((day / daysInProject) * props.width);\n\n      // Generate day markers\n      const dayInMonth = date.getDate();\n\n      if (plotDays & (dayInMonth % dayInterval === 0) && dayInMonth > 1) {\n        lines.push({\n          x1: xCoord,\n          y1: CALENDAR_TIMELINE_TOP,\n          x2: xCoord,\n          y2: CALENDAR_TIMELINE_TOP + dayLineHeight,\n          id: lines.length + 1,\n        });\n\n        labels.push({\n          text: new Intl.DateTimeFormat('en-US', {\n            day: '2-digit',\n          }).format(startDate.addDays(day)),\n          x: xCoord,\n          y: CALENDAR_TIMELINE_TOP + dayLineHeight + dt_margin,\n          id: labels.length + 1,\n        });\n      }\n\n      // Generate month markers\n      const month = date.getMonth();\n      let monthLineY1 = 0;\n      let monthLineY2 = 0;\n      let monthLabelY = 0;\n\n      if (plotMonths & (dayInMonth === 1) && month % monthInterval === 0) {\n        monthLineY1 = CALENDAR_TIMELINE_TOP;\n        monthLineY2 = plotDays\n          ? CALENDAR_TIMELINE_TOP + dayMarkerHeight\n          : (monthLineY2 = CALENDAR_TIMELINE_TOP + dt_margin);\n        monthLabelY = monthLineY2 + dt_margin;\n\n        lines.push({\n          x1: xCoord,\n          y1: monthLineY1,\n          x2: xCoord,\n          y2: monthLineY2,\n          id: lines.length + 1,\n        });\n\n        labels.push({\n          text: new Intl.DateTimeFormat('en-US', {\n            month: 'short',\n          }).format(date),\n          x: xCoord,\n          y: monthLabelY,\n          id: labels.length + 1,\n        });\n\n        if (firstMonthToPlot) {\n          labels.push({\n            text: new Intl.DateTimeFormat('en-US', {\n              year: 'numeric',\n            }).format(date),\n            x: xCoord,\n            y: monthLabelY + monthLabelHeight + dt_margin,\n            id: labels.length + 1,\n          });\n\n          firstMonthToPlot = false;\n        }\n      }\n\n      // Plot year markers\n      const yearInProject = date.getFullYear() - startDate.getFullYear();\n\n      if (\n        (month === 0) &\n        (dayInMonth === 1) &\n        (yearInProject % yearInterval === 0)\n      ) {\n        let yearLineY1;\n        let yearLineY2;\n        let yearLabelY;\n\n        if (plotMonths) {\n          yearLineY1 = monthLineY2;\n          yearLineY2 = monthLineY2;\n          yearLabelY = monthLabelY + monthLabelHeight + dt_margin;\n        } else {\n          yearLineY1 = CALENDAR_TIMELINE_TOP;\n          yearLineY2 = CALENDAR_TIMELINE_TOP + dt_margin;\n          yearLabelY = CALENDAR_TIMELINE_TOP + 2 * dt_margin;\n        }\n\n        lines.push({\n          x1: xCoord,\n          y1: yearLineY1,\n          x2: xCoord,\n          y2: yearLineY2,\n          id: lines.length + 1,\n        });\n\n        labels.push({\n          text: new Intl.DateTimeFormat('en-US', {\n            year: 'numeric',\n          }).format(date),\n          x: xCoord,\n          y: yearLabelY,\n          id: labels.length + 1,\n        });\n      }\n    }\n\n    const lineStyle = {\n      stroke: '#FFF',\n      strokeWidth: 2,\n      strokeLinecap: 'round',\n    };\n\n    // TODO not sure why I need to explicitly set/limit the height of the svg to 35px for it not to otherwise get the height 152 from somewhere\n    return (\n      <div id=\"calendar-timeline\">\n        <svg\n          width={props.width + 2 * props.margin}\n          height={CALENDAR_TIMELINE_HEIGHT}\n        >\n          {labels.map(label => (\n            <text\n              key={label.id}\n              x={label.x}\n              y={label.y}\n              dominantBaseline=\"hanging\"\n              textAnchor=\"middle\"\n            >\n              {label.text}\n            </text>\n          ))}{' '}\n          {lines.map(line => (\n            <line\n              key={line.id}\n              x1={line.x1}\n              y1={line.y1}\n              x2={line.x2}\n              y2={line.y2}\n              style={lineStyle}\n            />\n          ))}{' '}\n        </svg>\n      </div>\n    );\n  } else {\n    /* console.log('No props.timespan'); */\n    return <svg />;\n  }\n}\n\nexport default memo(CalendarTimeline);\n","/Users/fredrik/dev/flowanimator/client/src/slider.js",["133"],"import React, { memo } from 'react';\n\nconst SLIDER_HEIGHT = 32;\nconst BAR_HEIGHT = 15;\nconst BAR_RADIUS = BAR_HEIGHT / 2;\nconst BAR_Y = 0;\nconst BUTTON_RADIUS = 15;\n\nfunction Slider(props) {\n  /* console.log('Render Slider'); */\n\n  const foregroundWidth =\n    (props.loadProgress / props.animationDuration) * props.width;\n\n  const progressX =\n    props.margin +\n    (props.animationTime / props.animationDuration) * props.width;\n\n  const handleStartDrag = event => {\n    document.addEventListener('mousemove', handleDrag);\n    document.addEventListener('mouseup', handleDragEnd);\n  };\n\n  const handleDrag = event => {\n    const draggedAnimationTime = clientXToAnimationTime(event.clientX);\n    props.setAnimationTime(draggedAnimationTime);\n  };\n\n  const handleDragEnd = event => {\n    document.removeEventListener('mousemove', handleDrag);\n    document.removeEventListener('mouseup', handleDragEnd);\n  };\n\n  const handleBarClick = event => {\n    const clickedAnimationTime = clientXToAnimationTime(event.clientX);\n    props.setAnimationTime(clickedAnimationTime);\n  };\n\n  const clientXToAnimationTime = clientX => {\n    // The line caps make the line wider than its width property, thus necessary\n    // to limit the possible clicked x coordinate to the interval (0,width)\n    const newProgressX = Math.max(\n      // not less than 0\n      Math.min(\n        // not more than width\n        clientX - props.margin,\n        (props.loadProgress / props.animationDuration) * props.width\n      ),\n      0\n    );\n    const animationTime =\n      (newProgressX / props.width) * props.animationDuration;\n    return animationTime;\n  };\n\n  /*  const sliderBackgroundStyle = {\n    stroke: '#fff',\n    opacity: '50%',\n    strokeWidth: BAR_HEIGHT + 'px',\n    strokeLinecap: 'round',\n  };\n\n  const sliderForegroundStyle = {\n    stroke: '#fff',\n    opacity: '100%',\n    strokeWidth: BAR_HEIGHT + 'px',\n    strokeLinecap: 'round',\n  };\n\n  const buttonForegroundStyle = {\n    fill: '#000',\n    opacity: '80%',\n  };*/\n\n  const sliderStyle = {\n    // position: 'relative',\n    // minHeight: SLIDER_HEIGHT,\n    height: SLIDER_HEIGHT,\n    marginTop: BUTTON_RADIUS / 2,\n  };\n\n  const sliderBackgroundStyle = {\n    position: 'relative',\n    left: props.margin - BAR_RADIUS,\n    top: BAR_Y,\n    zIndex: 1,\n    width: props.width + 2 * BAR_RADIUS,\n    height: BAR_HEIGHT,\n    backgroundColor: '#fff',\n    opacity: '50%',\n    borderRadius: BAR_RADIUS,\n  };\n\n  const sliderForegroundStyle = {\n    position: 'relative',\n    left: props.margin - BAR_RADIUS,\n    top: -BAR_HEIGHT,\n    zIndex: 2,\n    width: foregroundWidth + 2 * BAR_RADIUS,\n    height: BAR_HEIGHT,\n    backgroundColor: '#fff',\n    borderRadius: BAR_RADIUS,\n    cursor: 'pointer',\n  };\n\n  const sliderButtonStyle = {\n    position: 'relative',\n    top: -1.5 * BAR_HEIGHT - BUTTON_RADIUS,\n    left: progressX - BUTTON_RADIUS,\n    zIndex: 3,\n    backgroundColor: '#000',\n    opacity: '80%',\n    height: BUTTON_RADIUS * 2,\n    width: BUTTON_RADIUS * 2,\n    borderRadius: BUTTON_RADIUS,\n    cursor: 'grab',\n  };\n\n  return (\n    <div id=\"slider\" style={sliderStyle}>\n      <div id=\"sliderBackground\" style={sliderBackgroundStyle} />\n      <div\n        id=\"sliderForeground\"\n        style={sliderForegroundStyle}\n        onMouseDown={handleBarClick}\n      />\n      <div\n        id=\"sliderButton\"\n        style={sliderButtonStyle}\n        onMouseDown={handleStartDrag}\n      />\n    </div>\n  );\n}\n\nexport default memo(Slider);\n","/Users/fredrik/dev/flowanimator/client/src/column.js",["134"],"/**\n * @file src/column.js\n * @description Defines the {@link Column} class for representing the columns of the\n * Jira board being animated, and the {@link ColumnCollection} class for creating\n * the columns and holding the list of columns of the current board and performing\n * certain operations on them.\n */\n\nimport React, { memo } from 'react';\nimport { isSafari } from 'get-browser';\n\nexport const UNCREATED_COLUMN_ID = 0;\nconst FIRST_COLUMN_ID = 1;\nconst COMMITTED_COLUMN = 2;\nconst DONE_COLUMN_FROM_END = 1;\nconst PADDING_BOTTOM = 5;\n\n/**\n * @constructor Column\n * @description Constructor for objects to represent the columns of the Jira\n * board being animated. Column objects are created by the column collection\n * object (`Columns.addColumnsFromJira`) based on the column information in the\n * board configuration data read from Jira.\n * @param number Running number of the columns. 0 is reserved for the virtual and\n * invisible \"uncreated\" column (where stories are initially placed when they are\n * constructed and from where they fly into the first \"real\" column) and numbers 1\n * onwards are for the \"real\" columns.\n * @param name Name of the column, which will be displayed on the ui.\n * @param statuses A list of Jira workflow statuses, which are mapped to\n * this column\n */\nexport function Column(number, name, statuses, visible) {\n  this.number = number;\n  this.name = name;\n  this.storiesInColumn = [];\n  this.text = {};\n  this.center = 0;\n  this.statusesInColumn = [];\n  if (statuses) {\n    statuses.forEach(status => this.statusesInColumn.push(status.id));\n  }\n  this.visible = visible;\n  /**\n   * @memberof Column\n   * @instance\n   * @method clear\n   * @description Removes the textural representation of the column from the ui\n   * and clears its list of associated stories and statuses. Used when clearing\n   * the data of a loaded project, including its columns, before loading a\n   * new project with new columns.\n   */\n  this.clear = function() {\n    // Remove the textual representation of this column (if any) from the ui\n    if (this.text.remove) this.text.remove();\n    // Not sure whether this is really necessary, but it should not hurt\n    this.storiesInColumn.length = 0;\n    // As above\n    this.statusesInColumn.length = 0;\n  };\n}\n\n/**\n * @constructor ColumnCollection\n * @description Constructor for an object that creates the columns of the\n * current board and holds a list of these columns and performs certain\n * operations on them.\n */\nexport function ColumnCollection() {\n  this.columns = [];\n  /**\n   * @memberof ColumnCollection\n   * @instance\n   * @method addColumnsFromFile\n   * @description Creates columns from input originating from a CSV file\n   * selected by the user. NOT IN USE FOR THE MOMENT.\n   * @param columnFields An array of field names, which was constructed\n   * in the calling function from the first line of the CSV file.\n   */\n  this.addColumnsFromFile = function(columnFields) {\n    // Start by creating a virtual and invisible \"uncreated\" column for\n    // initially holding newly created stories before they make their\n    // transition into the first real column.\n    const uncreatedColumn = new Column(0, 'Uncreated', null, false);\n    this.columns.push(uncreatedColumn);\n    // Loop through the array of column names and create column objects\n    // for each encountered column name\n    for (var fieldNo = 0; fieldNo < columnFields.length; fieldNo++) {\n      // disregard any empty fields, which might be found at the right end of the line\n      if (columnFields[fieldNo] !== '') {\n        const columnNr = fieldNo + 1; // column number 0 used for uncreated column, hence +1\n        const column = new Column(columnNr, columnFields[fieldNo], null, true);\n        this.columns.push(column);\n      }\n    }\n  };\n  /**\n   * @memberof ColumnCollection\n   * @instance\n   * @method addColumnsFromJira\n   * @description Creates columns based on input originating from\n   * board configuration data read from the Jira REST API in the calling\n   * functions.\n   * @param columnsFromJira An array of column data, which was constructed\n   * in the calling function based on board configuration data read from the\n   * Jira REST API.\n   */\n  this.addColumnsFromJira = columnsFromJira => {\n    // Start by creating a virtual and invisible \"uncreated\" column for\n    // initially holding newly created stories before they make their\n    // transition into the first real column.\n    const uncreatedColumn = new Column(0, 'Uncreated', null, false);\n    this.columns.push(uncreatedColumn);\n    // Loop through the array of column data and create column objects\n    // for each encountered column record.\n    let columnNr = 0;\n    for (var fieldNo = 0; fieldNo < columnsFromJira.length; fieldNo++) {\n      // Include only columns with at least one status mapped to them\n      if (columnsFromJira[fieldNo].statuses.length > 0) {\n        // Create a new Column object...\n        columnNr++; // column number 0 used for uncreates column, hence start numbering from 1\n        const name = columnsFromJira[fieldNo].name;\n        const statuses = columnsFromJira[fieldNo].statuses;\n        const column = new Column(columnNr, name, statuses, true);\n        // ...and push it onto our list of columns\n        this.columns.push(column);\n      }\n    }\n  };\n\n  /**\n   * @memberof ColumnCollection\n   * @instance\n   * @method getCount\n   * @description Returns the number of columns in the column collection.\n   */\n  this.getCount = () => {\n    return this.columns.length;\n  };\n\n  /**\n   * @memberof ColumnCollection\n   * @instance\n   * @method getColumn\n   * @description Returns the column with the given index. Called from\n   * StoryCollection.addStoriesFromFile, which is not in use for the moment.\n   * @param columnNr {integer} The index of the column to be retrieved.\n   */\n  this.getColumn = columnNr => {\n    return this.columns[columnNr];\n  };\n\n  /**\n   * @memberof ColumnCollection\n   * @instance\n   * @method getColumns\n   * @description Returns an array with all columns in the column collection.\n   */\n  this.getRealColumns = () => {\n    return [...this.columns.slice(1)]; // return a copy of the columns array\n  };\n\n  /**\n   * @memberof ColumnCollection\n   * @instance\n   * @method getUncreatedColumn\n   * @description Returns the virtual \"uncreated\" column used for holding\n   * stories before they transition into the first real column.\n   */\n  this.getUncreatedColumn = () => {\n    return this.columns[UNCREATED_COLUMN_ID];\n  };\n\n  /**\n   * @memberof ColumnCollection\n   * @instance\n   * @method getFirstColumn\n   * @description Returns the first \"real\" column in the column collection.\n   * Called from **`Animation.addStoriesFromJira`**.\n   */\n  this.getFirstColumn = () => {\n    return this.columns[FIRST_COLUMN_ID];\n  };\n\n  /**\n   * @memberof ColumnCollection\n   * @instance\n   * @method getCommittedColumn\n   * @description Returns the column from of which stories are considered\n   * to be \"committed\", i.e. meant to be actively worked on. This is typically\n   * the second column and for now we assume that this is always the case.\n   * Used in Animation.generateColorAnimation() where the\n   * coloring of a story according to age starts from the point when the\n   * story enters the committed column.\n   */\n  this.getCommittedColumn = () => this.columns[COMMITTED_COLUMN];\n\n  /**\n   * @memberof ColumnCollection\n   * @instance\n   * @method getDoneColumn\n   * @description Returns the column from of which stories are considered\n   * to be \"done\", i.e. fully ready. This is typically the last column and for\n   * now we assume that this is always the case. Used in\n   * Animation.generateColorAnimation() where the coloring of a story according\n   * to age ends at the point when the story reaches the done column.\n   */\n  this.getDoneColumn = () =>\n    this.columns[this.columns.length - DONE_COLUMN_FROM_END];\n\n  /**\n   * @memberof ColumnCollection\n   * @instance\n   * @method getColumnOfStatus\n   * @description Returns the column to whih a certain status in the Jira\n   * workflow has been mapped.\n   */\n  this.getColumnOfStatus = statusNr => {\n    for (var i = 0; i < this.columns.length; i++) {\n      const column = this.columns[i];\n      // A status should never be mapped to more than one column, so we can\n      // return the first column where the status is found and exit.\n      if (column.statusesInColumn.indexOf(statusNr) >= 0) {\n        return column;\n      }\n    }\n    // Getting this far meant that no column containing the given status was found\n    return null;\n  };\n\n  /**\n   * @memberof ColumnCollection\n   * @instance\n   * @method clear\n   * @description Removes all columns from the column collection. Used when\n   * clearing the data of a loaded project, including its columns, before\n   * loading a new project with new columns. The column collection itself\n   * does not get removed, only emptied of its columns.\n   */\n  this.clear = () => {\n    this.columns.forEach(column => {\n      column.clear();\n      column = null;\n    });\n    // Not sure whether this is really necessary, but it should not hurt\n    this.columns.length = 0;\n  };\n}\n\nfunction ColumnLabels(props) {\n  /* console.log('Render ColumnLabels'); */\n  /* console.log(props); */\n  /* console.log(props.margin); */\n\n  const marginBottom = isSafari() ? 32 : 0;\n\n  const labelWrapperStyle = {\n    display: 'flex',\n    flexDirection: 'row',\n    paddingRight: props.margin,\n    paddingBottom: PADDING_BOTTOM,\n    paddingLeft: props.margin,\n    marginBottom: marginBottom,\n  };\n\n  const labelContainerStyle = {\n    flex: 1,\n    height: '20px',\n    margin: '2px 8px 6px 8px',\n  };\n\n  const labelLineStyle = {\n    height: '3px',\n    marginBottom: '3px',\n    borderRadius: '2px',\n    backgroundColor: '#fff',\n    opacity: '60%',\n  };\n\n  const labelStyle = {\n    overflow: 'hidden',\n    textOverflow: 'ellipsis',\n    padding: '2px',\n  };\n  //  whiteSpace: 'nowrap',\n\n  if (props.columns) {\n    return (\n      <div id=\"column-labels\" style={labelWrapperStyle}>\n        {props.columns.getRealColumns().map(column => (\n          <div\n            key={column.name}\n            style={{ ...labelContainerStyle, ...labelStyle }}\n          >\n            <div style={labelLineStyle} />\n            {column.name}\n          </div>\n        ))}\n      </div>\n    );\n  } else {\n    return <div id=\"column-labels\" />;\n  }\n}\nexport default memo(ColumnLabels);\n","/Users/fredrik/dev/flowanimator/client/src/timer.js",["135"],"export default function Timer(setAnimationTime, handleAnimationFinished) {\n  const INTERVAL = 20;\n\n  this.id = Math.round(Math.random() * 100);\n  this.loadProgress = 0;\n  this.intervalId = undefined;\n\n  // BOOOKMARK\n  // TODO make timer stop when end of (so far loaded) animation reached\n\n  this.setLoadProgress = loadProgress => {\n    this.loadProgress = loadProgress;\n  };\n\n  this.play = () => {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n    this.intervalId = setInterval(() => {\n      setAnimationTime(previousAnimationTime => {\n        if (previousAnimationTime + INTERVAL >= this.loadProgress) {\n          handleAnimationFinished();\n        }\n        return Math.min(previousAnimationTime + INTERVAL, this.loadProgress);\n      });\n    }, INTERVAL);\n  };\n\n  this.pause = () => {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      this.intervalId = undefined;\n    }\n  };\n}\n","/Users/fredrik/dev/flowanimator/client/src/story.js",["136"],"/**\n * @file src/story.js\n * @description Defines the [Story]{@link Story} class for representing the stories to\n * be animated, and the [StoryCollecction]{@link StoryCollection} class for creating the stories\n * and holding the list of stories and performing certain operations on them.\n */\nimport React, { useCallback, useState, memo } from 'react';\nimport { Transition } from './transition.js';\nimport { amountOfIntervalCovered, utils, measureStringWidth } from './utils.js';\nimport { Move, MovesCollection } from './move.js';\nimport { TransitionCollection } from './transition.js';\nimport StoryPopup from './story-popup.js';\n\n/****************************************************************************\n                                 STORY\n ****************************************************************************/\n/**\n * @constructor Story\n * @description Constructor for objects to represent the stories in the current\n * project.\n * @param id Id (Jira key) of the story to be created\n * @param name Name (Jira summary) of the story to be created\n * @param column Column into which the story should initially be placed\n */\nfunction Story(id, name, fields, initialColumn, serverUrl, animUtils) {\n  this.id = id;\n  this.name = name;\n  this.fields = fields;\n  this.column = initialColumn;\n  this.initialColumn = this.column;\n  this.url = serverUrl + '/browse/' + id;\n  // Add this story to the list of stories in the column where this story is\n  // initially placed...\n  this.column.storiesInColumn.push(this);\n  // ...and take note of the vertical slot in which this story landed in that column\n  this.verticalSlot = this.column.storiesInColumn.indexOf(this);\n  this.initialVerticalSlot = this.verticalSlot;\n  this.transitions = [];\n  this.previousTransitionAnimationFinish = 0;\n  this.createdDate = new Date(fields.created).getTime();\n  this.committedDate = null;\n  this.doneDate = null;\n  this.moves = [];\n  this.modelX = 0;\n  this.modelY = 0;\n  this.screenX = -100;\n  this.screenY = 0;\n\n  /**\n   * @memberof Story\n   * @instance\n   * @method setTransitions\n   * @description Set this story's transitions from an array of transitions read\n   * from Jira\n   * @param transitions An array with transitions to be set on the story\n   */\n  this.setTransitions = transitions => {\n    this.transitions = transitions;\n  };\n\n  /**\n   * @memberof Story\n   * @instance\n   * @method getCreatedDate\n   * @description Returns the date when the story got created\n   */\n\n  this.getCreatedDate = () => {\n    return new Intl.DateTimeFormat('fi-FI', {\n      day: 'numeric',\n      month: 'numeric',\n      year: 'numeric',\n    }).format(new Date(this.createdDate));\n  };\n\n  // TODO: is this setter functions (and other similar ones) adding any value?\n  /**\n   * @memberof Story\n   * @instance\n   * @method setCommittedDate\n   * @description Set the date when the story got \"committed\", i.e. when the\n   * story got moved into a column that indicates that the story has been\n   * selected to be worked on. This date is used in {@link generateColorAnimation}\n   * @param timestamp A date value (in Unix Epoch milliseconds) to be set as\n   * the story's committed date\n   */\n  this.setCommittedDate = timestamp => {\n    this.committedDate = timestamp;\n  };\n\n  /**\n   * @memberof Story\n   * @instance\n   * @method getCommittedDate\n   * @description Returns the date when the story got \"committed\", i.e. when the\n   * story got moved into a column that indicates that the story has been\n   * selected to be worked on. This date is used in {@link generateColorAnimation}\n   */\n  this.getCommittedDate = () => {\n    return this.committedDate;\n  };\n\n  /**\n   * @memberof Story\n   * @instance\n   * @method setDoneDate\n   * @description Set the date when the story got \"done\", i.e. when the\n   * story got moved into a column that indicates that the story is fully ready.\n   * This date is used in {@link generateColorAnimation}\n   * @param timestamp A date value (in Unix Epoch milliseconds) to be set as\n   * the story's done date\n   */\n  this.setDoneDate = timestamp => {\n    this.doneDate = timestamp;\n  };\n\n  /**\n   * @memberof Story\n   * @instance\n   * @method getDoneDate\n   * @description Return the date when the story got \"done\", i.e. when the\n   * story got moved into a column that indicates that the story is fully ready.\n   * This date is used in {@link generateColorAnimation}\n   */\n  this.getDoneDate = () => {\n    return this.doneDate;\n  };\n\n  /**\n   * @memberof Story\n   * @instance\n   * @method getCycleTime\n   * @description Return the Cycle Time of the story, i.e. timespan from\n   * Committed Date to Done Date\n   */\n\n  this.getCycleTime = () => {\n    if (this.doneDate && this.committedDate) {\n      return utils.msToDays(this.doneDate - this.committedDate);\n    } else {\n      return 'Still in process';\n    }\n  };\n\n  /**\n   * @memberof Story\n   * @instance\n   * @method getLeadTime\n   * @description Return the Lead  Time of the story, i.e. timespan from\n   * Created Date to Done Date\n   */\n\n  this.getLeadTime = () => {\n    if (this.createdDate && this.doneDate) {\n      return utils.msToDays(this.doneDate - this.createdDate);\n    } else {\n      return 'Still in process';\n    }\n  };\n\n  /**\n   * @memberof Story\n   * @instance\n   * @method getNextTransition\n   * @description Return the next transition, if any, after the transition\n   * given as a parameter. This is used in {@link AnimationGenerator}.\n   */\n  this.getNextTransition = baselineTransition => {\n    // Return the first of this story's transitions that comes after the baseline transition in sort order\n    // Assuming that this story's transitions have been pushed onto the transitions array\n    // in the order of the timestamps\n    for (var i = 0; i < this.transitions.length; i++) {\n      const transition = this.transitions[i];\n      if (transition.getSortOrder(transition, baselineTransition) > 0) {\n        return transition;\n      }\n    }\n    // else, if no subsequent transition was found after the baselineTransition\n    return null;\n  };\n\n  this.getLastTransitonDate = () => {\n    if (this.transitions.length > 0) {\n      return this.transitions[this.transitions.length - 1];\n    }\n  };\n\n  /**\n   * @memberof Story\n   * @instance\n   * @method addMove\n   * @description\n   */\n  this.addMove = (\n    type,\n    start,\n    duration,\n    fromColumn,\n    toColumn,\n    fromSlot,\n    toSlot\n  ) => {\n    const move = new Move(\n      this,\n      type,\n      start,\n      duration,\n      fromColumn,\n      toColumn,\n      fromSlot,\n      toSlot\n    );\n    this.moves.push(move);\n    return move;\n  };\n\n  /**\n   * @memberof Story\n   * @instance\n   * @method getPositionAtAnimationTime\n   * @description\n   */\n  /*\n  this.getPositionAtAnimationTime = animationTime => {\n    const UNCREATED_COLUMN = 0;\n    const UNCREATED_SLOT = 0;\n\n    // console.log('getPositionAtAnimationTime');\n    // console.log(this.id);\n    // console.log(animationTime);\n    // console.log();\n\n    if (!this.columnToXCoord || !this.slotToYCoord) {\n      return { x: -100, y: -100 };\n    }\n    // Traverse the story's moves from end towards beginning\n    // until we come across the first move that starts at or before\n    // the given animation time\n\n    for (let i = this.moves.length - 1; i >= 0; i--) {\n      let move = this.moves[i];\n\n      if (move.start <= animationTime) {\n        const startX = this.columnToXCoord(move.fromColumn.number);\n        const startY = this.slotToYCoord(move.fromSlot);\n        const endX = this.columnToXCoord(move.toColumn.number);\n        const endY = this.slotToYCoord(move.toSlot);\n        const progressFactor = Math.min(\n          (animationTime - move.start) / move.duration,\n          1\n        );\n        const x = startX + progressFactor * (endX - startX);\n        const y = startY + progressFactor * (endY - startY);\n        // console.log('x: ' + x + ', y: ' + y);\n        return { x: x, y: y };\n      }\n    }\n    // Story had no moves starting before given animation time, or no moves at all\n    const x = this.columnToXCoord(UNCREATED_COLUMN);\n    const y = this.slotToYCoord(UNCREATED_SLOT);\n    return { x: x, y: y };\n  };\n*/\n\n  /**\n   * @memberof Story\n   * @instance\n   * @method getAppearanceAtAnimationTime\n   * @description\n   */\n\n  this.getAppearanceAtAnimationTime = animationTime => {\n    // TODO: is there a better way to pass calendarDateToAnimationTime and AGE_COLORING_MAX_AGE than by passing it down in animUtils to StoryCollection and Story?\n\n    let colorAnimationProgress = 0;\n\n    if (this.committedDate) {\n      const colorAnimationStart = animUtils.calendarDateToAnimationTime(\n        this.committedDate\n      );\n\n      const colorAnimationEnd = animUtils.calendarDateToAnimationTime(\n        Math.min(\n          this.doneDate || animUtils.lastTransitionDate,\n          this.committedDate + animUtils.AGE_COLORING_MAX_AGE\n        )\n      );\n\n      colorAnimationProgress =\n        amountOfIntervalCovered(\n          animationTime,\n          colorAnimationStart,\n          colorAnimationEnd\n        ) /\n        animUtils.calendarDaysToAnimationTime(animUtils.AGE_COLORING_MAX_AGE);\n    }\n\n    function decToHex(dec) {\n      var hex = Math.round(dec).toString(16);\n      return hex.length === 1 ? '0' + hex : hex;\n    }\n    const gb = (1 - colorAnimationProgress) * 255;\n    const fillcolor = '#ff' + decToHex(gb) + decToHex(gb);\n    const fontColor = '#000';\n\n    return { fillColor: fillcolor, fontColor: fontColor, opacity: 1 };\n  };\n\n  /**\n   * @memberof Story\n   * @instance\n   * @method clear\n   * @description Clear this story's data. Used when clearing the data of a\n   * loaded project, including its stories, before loading a new project with\n   * new stories.\n   */\n  this.clear = () => {\n    this.transitions.length = 0;\n    this.moves.length = 0;\n  };\n\n  this.getStatusStays = () => {\n    console.log('getStatusStays');\n    const statusStays = [];\n    for (let i = 0; i < this.transitions.length - 1; i++) {\n      const transition = this.transitions[i];\n      const nextTransition = this.transitions[i + 1];\n      const daysInStatus = utils.msToDays(\n        nextTransition.timestamp - transition.timestamp\n      );\n      console.log(transition);\n      statusStays.push({\n        id: i,\n        status: transition.toColumn.name,\n        days: daysInStatus,\n        date: transition.date,\n      });\n    }\n    console.log(statusStays);\n    return statusStays;\n  };\n}\n\n/****************************************************************************\n                             STORY COLLECTION\n ****************************************************************************/\n/**\n * @constructor StoryCollection\n * @description Class for creating stories and for holding the list of stories\n * in the currently loaded project and for performing certain operations on them\n */\nexport function StoryCollection(animUtils) {\n  this.stories = [];\n  this.moves = new MovesCollection();\n  this.transitions = new TransitionCollection(); // needs to be var since we'll be using .concat\n  this.previousAnimationTime = 0;\n  this.maxTokenStringWidth = 0;\n\n  this.activeMoves = [];\n\n  /**************************************************************************\n                            addStoriesFromFile\n   **************************************************************************/\n  /**\n   * @memberof StoryCollection\n   * @instance\n   * @method addStoriesFromFile\n   * @description Creates stories from input originating from a CSV file\n   * selected by the user. NOT IN USE FOR THE MOMENT.\n   */\n  this.addStoriesFromFile = (\n    storyLines,\n    delimiter,\n    attribute_fields_in_import_file,\n    columns\n  ) => {\n    //  Read and create stories and column transitions from subsequent lines in file\n    storyLines.forEach(storyLine => {\n      if (storyLine !== '' && storyLine.substr(1, 1) !== delimiter) {\n        // disregard any possible empty lines, or lines consisting only of delimiters, which may be found at the end of the file\n\n        const storyFields = storyLine.split(delimiter);\n        const id = storyFields[0];\n        const name = storyFields[2];\n        const column = columns.getUncreatedColumn();\n        const story = new Story(id, name, column, animUtils);\n        this.stories.push(story);\n\n        // Create the story's transitions\n        const transitionFields = storyFields.slice(\n          attribute_fields_in_import_file\n        );\n        const thisStorysTransitions = [];\n        var fromColumn = columns.getUncreatedColumn();\n        var previousTransitionFinishDateTime = 0;\n\n        for (var fieldNo = 0; fieldNo < transitionFields.length; fieldNo++) {\n          if (transitionFields[fieldNo] !== '') {\n            // disregard empty fields\n\n            const toColumn = columns.getColumn(fieldNo + 1); // column numbering starts from 1 since columns[0] is the uncreated column\n            const timestamp = utils\n              .stringToDateTime(transitionFields[fieldNo])\n              .getTime();\n\n            const transitionStartDateTime = Math.max(\n              timestamp,\n              previousTransitionFinishDateTime\n            );\n\n            const transition = new Transition(\n              story,\n              fromColumn,\n              toColumn,\n              timestamp,\n              transitionStartDateTime\n            );\n\n            thisStorysTransitions.push(transition);\n\n            previousTransitionFinishDateTime =\n              transitionStartDateTime + transition.getDurationInCalendarTime();\n\n            fromColumn = toColumn;\n\n            if (\n              !story.getCommittedDate() &&\n              toColumn.number >= columns.getCommittedColumn().number\n            ) {\n              story.setCommittedDate(timestamp);\n            }\n            if (\n              !story.getDoneDate() &&\n              toColumn.number >= columns.getDoneColumn().number\n            ) {\n              story.setDoneDate(timestamp);\n            }\n          } // if (transitionFields[fieldNo] !== '')\n        } // for\n\n        story.setTransitions(thisStorysTransitions);\n        this.transitions.addTransitions(thisStorysTransitions);\n        this.transitions.sort();\n      } // if (storyLine != '' && storyLine.substr(1, 1) != delimiter)\n    }); // forEach storyLine\n  };\n\n  /**************************************************************************\n                              addStoriesFromJira\n   **************************************************************************/\n  /**\n   * @memberof StoryCollection\n   * @instance\n   * @method addStoriesFromJira\n   * @description Creates stories and their transitions and visual representations\n   * based on an array of Jira issue data retrieved from the Jira REST API in\n   * the calling functions.\n   * @param issues An array of Jira issues retrieved\n   * from the Jira REST API in the calling functions\n   * @param columns A reference to the column collection, from which certain\n   * information is needed when creating the transitions\n   */\n  this.addStoriesFromJira = (issues, columns, serverUrl) => {\n    // Keep track of the maximum required token width needed to fit the longest\n    // Jira key in the set of issues; at the end of the procedure, the width of\n    // all tokens will be set to this width\n    // var maxTokenWidth = 0;\n\n    issues.forEach(issue => {\n      const id = issue.key;\n      const name = issue.fields.summary;\n      const fields = issue.fields;\n      const uncreatedColumn = columns.getUncreatedColumn();\n      // Create a new Story...\n      const story = new Story(\n        id,\n        name,\n        fields,\n        uncreatedColumn,\n        serverUrl,\n        animUtils\n      );\n      // ...and push it onto our list of stories in the current project\n      this.stories.push(story);\n      // Update our bookkeeping of the maximum token width, if needed\n      // maxTokenWidth = Math.max(maxTokenWidth, story.token.tooltip.bbox().width);\n      this.maxTokenStringWidth = Math.max(\n        measureStringWidth(id, TOKEN_FONT),\n        this.maxTokenStringWidth\n      );\n\n      // Create the story's transitions\n\n      const thisStorysTransitions = [];\n      var previousTransitionFinishDateTime = 0;\n\n      // First create a \"virtual\" transition from uncreated column to the\n      // fromColumn of the first real transition, timed at the time the issue was created\n      var fromColumn = columns.getUncreatedColumn();\n      var toColumn = columns.getFirstColumn();\n      // Extract the timestamp when the issue was created to be used as the\n      // timestamp of this transition; NB the time zone offset \"+HHMM\" in\n      // the timestamp string must be reformatted to \"+HH:MM\" for Safari to accept it\n      var timeStampString = issue.fields.created.replace(/(.+)(..)$/, '$1:$2');\n      const createdDate = new Date(timeStampString).getTime();\n      const transition = new Transition(\n        story,\n        fromColumn,\n        toColumn,\n        createdDate,\n        createdDate\n      );\n      thisStorysTransitions.push(transition);\n\n      // Set the committed date to the created date in case the first transition\n      // goes directly to the committed column or beyond\n      if (\n        !story.getCommittedDate() &&\n        toColumn.number >= columns.getCommittedColumn().number\n      ) {\n        story.setCommittedDate(createdDate);\n      }\n      // Set the done date to the created date in case the first transition\n      // goes directly to the done column\n      if (\n        !story.getDoneDate() &&\n        toColumn.number >= columns.getDoneColumn().number\n      ) {\n        story.setDoneDate(createdDate);\n      }\n      fromColumn = toColumn;\n      // Record the moment when this transition finished. This is expressed in\n      // calendar date/time since we don't know anything about animation times yet\n      // until AnimationData.buildAnimation() has run. We will use this value when\n      // creating subsequent transitions to make sure one transition doesn't\n      // start before the prior one has had the time to finish.\n\n      previousTransitionFinishDateTime =\n        createdDate + transition.getDurationInCalendarTime();\n\n      // The issue's transition history is found in the histories field of the\n      // JSON response from the Jira REST API\n      const histories = issue.changelog.histories;\n      // Make sure the transitions are sorted in chronological order;\n      // TODO: Is this really needed, do they always come sorted that way?\n      histories.sort((firstHistory, secondHistory) => {\n        if (new Date(firstHistory.created) >= new Date(secondHistory.created)) {\n          return 1;\n        } else {\n          return -1;\n        }\n      });\n\n      // Loop through the JSON response from the Jira REST API and create\n      // status transitions based on the status transition information found\n      histories.forEach(history => {\n        history.items.forEach(item => {\n          // look for the field that represents a status transition\n          if (item.field === 'status') {\n            // get the column (if any) that the toStatus is mapped to\n            toColumn = columns.getColumnOfStatus(item.to);\n            // Only create transitions when the issue is moving to a status\n            // that has been mapped to a column (=toColumn is truthy) and the\n            // column that this status is mapped to is different from the\n            // current column of the issue\n            if (toColumn && toColumn !== fromColumn) {\n              // Extract the timestamp of this transition; NB the time zone\n              // offset \"+HHMM\" in the timestamp string must be reformatted\n              // to \"+HH:MM\" for Safari to accept it\n              timeStampString = history.created.replace(/(.+)(..)$/, '$1:$2');\n              const timestamp = new Date(timeStampString).getTime();\n              // Set the transition to start at the timestamp, or at the finish\n              // time of the previous transition, whichever is later; this way\n              // we avoid that one transition would start before the previous one\n              // has had the time to complete.\n              const transitionStartDateTime = Math.max(\n                timestamp,\n                previousTransitionFinishDateTime\n              );\n\n              // Create the transition...\n              const transition = new Transition(\n                story,\n                fromColumn,\n                toColumn,\n                timestamp,\n                transitionStartDateTime\n              );\n              // ...and push it onto our list of the story's transitions\n              thisStorysTransitions.push(transition);\n\n              // Check if the story has reached the committed column and if so,\n              // set the committed date if it wasn't set already\n              if (\n                !story.getCommittedDate() &&\n                toColumn.number >= columns.getCommittedColumn().number\n              ) {\n                story.setCommittedDate(timestamp);\n              }\n\n              // Check if the story has reached the done column and if so,\n              // set the done date if it wasn't set already\n              if (\n                !story.getDoneDate() &&\n                toColumn.number >= columns.getDoneColumn().number\n              ) {\n                story.setDoneDate(timestamp);\n              }\n\n              // The destination column of this transition will be the starting\n              // column of the next one\n              fromColumn = toColumn;\n\n              // Record the moment when this transition finished. This is expressed in\n              // calendar date/time since we don't know anything about animation times yet\n              // until Animation.buildAnimation() has run. We will use this value when\n              // creating subsequent transitions to make sure one transition doesn't\n              // start before the prior one has had the time to finish.\n              previousTransitionFinishDateTime =\n                transitionStartDateTime +\n                transition.getDurationInCalendarTime();\n            }\n          }\n        });\n      });\n\n      // Store all the generated transitions on the story...\n      story.setTransitions(thisStorysTransitions);\n      // ...and add them to the list of all transitions in the story collection\n      this.transitions.addTransitions(thisStorysTransitions);\n      this.transitions.sort();\n      animUtils.animationStartDate = this.transitions.getFirstTransitionDate();\n    });\n\n    // Set width of each token to the width required to fit the widest label\n    // this.stories.forEach(story => {\n    //   story.token.circle.width(maxTokenWidth + ui.TOKEN_MARGIN);\n    //   story.token.tooltip.cx(story.token.circle.cx());\n    //   story.token.tooltip.cy(story.token.circle.cy());\n    // });\n\n    // Also inform the ui of the width of the tokens, since this is needed\n    // when positioning the tokens on the ui\n    // ui.labelWidth = maxTokenWidth + ui.TOKEN_MARGIN;\n  };\n\n  /**************************************************************************\n                              getIterator\n   **************************************************************************/\n  /**\n   * @memberof StoryCollection\n   * @instance\n   * @method getIterator\n   * @description Generates an iterator over the stories in the story collection\n   * TODO: No longer needed?\n   */\n  this.getIterator = function*() {\n    for (var story of this.stories) {\n      yield story;\n    }\n  };\n\n  /**************************************************************************\n                              asArray\n   **************************************************************************/\n  /**\n   * @memberof StoryCollection\n   * @instance\n   * @method asArray\n   * @description Returns an array with the stories in the story collection\n   */\n  this.asArray = function() {\n    return this.stories;\n  };\n\n  /**************************************************************************\n                        updateTokensAtAnimationTime\n   **************************************************************************\n    /**\n     * @memberof StoryCollection\n     * @instance\n     * @method getTransitions\n     * @description Returns an array with the transitions in the story collection\n     */\n\n  this.updateTokensAtAnimationTime = animationTime => {\n    // Look for subsequent moves that should be active now\n    if (animationTime >= this.previousAnimationTime) {\n      // If animationTime moved forward (normal animation progress, or user\n      // clicked or dragged the animation time forward),\n      // we should be traversing the moves collection forward\n      let nextMove;\n      if (this.moves.activeMoves.head) {\n        nextMove = this.moves.activeMoves.head.next;\n      } else {\n        nextMove = this.moves.first;\n      }\n\n      while (nextMove) {\n        // Start from the latest added active move (\"head\") is one exists,\n        // otherwise start from the first move in the MovesCollection\n        if (nextMove.start <= animationTime) {\n          this.moves.addToActiveMoves(nextMove);\n        } else {\n          break;\n        }\n        nextMove = nextMove.next;\n      }\n    } else {\n      // If animationTime moved backwards (user\n      // clicked or dragged the animation time backwards),\n      // we should be traversing the moves collection backwards\n      // Start from the latest added active move (\"head\") is one exists.\n      // If no head exists, it would mean that no move has gotten activated yet,\n      // which would be highly unlikely since the first move always starts at\n      // animation time 0.\n      if (this.moves.activeMoves.head) {\n        let previousMove = this.moves.activeMoves.head.previous;\n        while (previousMove) {\n          if (\n            previousMove.start + animUtils.TRANSITION_DURATION >=\n            animationTime\n          ) {\n            this.moves.addToActiveMoves(previousMove);\n          } else {\n            break;\n          }\n          previousMove = previousMove.previous;\n        }\n      }\n    }\n    // Process the active moves and drop ones that should no longer be active\n    for (let move of this.moves.getActiveMoves()) {\n      const startX = move.fromColumn.number;\n      const startY = move.fromSlot;\n      const endX = move.toColumn.number;\n      const endY = move.toSlot;\n      const progressFactor = Math.max(\n        Math.min((animationTime - move.start) / move.duration, 1),\n        0\n      );\n      move.story.modelX = startX + progressFactor * (endX - startX);\n      move.story.modelY = startY + progressFactor * (endY - startY);\n\n      // Remove move from active moves after animation time has passed its end time\n      if (animationTime > move.end || animationTime < move.start) {\n        this.moves.removeFromActiveMoves(move);\n      }\n    }\n\n    this.previousAnimationTime = animationTime;\n  };\n\n  /**************************************************************************\n                            clear\n   **************************************************************************\n  /**\n   * @memberof StoryCollection\n   * @instance\n   * @method clear\n   * @description Clears and removes all stories from the story collection.\n   * Used when clearing the data of a loaded project, including its stories,\n   * before loading a new project with new stories. The story collection itself\n   * does not get removed, only emptied of its stories.\n   */\n  this.clear = () => {\n    this.stories.forEach(story => {\n      story.clear();\n      story = null;\n    });\n    this.stories.length = 0;\n    this.transitions.clear();\n    this.moves.clear();\n  };\n}\n\n/**************************************************************************\n                          Story Tokens\n **************************************************************************/\n\nconst TOKEN_HEIGHT = 18;\nconst TOKEN_FONT = 'Arial 10px';\nconst UNCREATED_COLUMN_X = -111;\n\nfunction StoryTokens(props) {\n  console.log('Render StoryTokens');\n  const [selectedStory, setSelectedStory] = useState(undefined);\n\n  // Set function on Move to give the x coordinate on the canvas of a column #\n  // Column 0 is the \"uncreated column\", numbering of real columns starts from 1\n  const columnToXCoord = useCallback(\n    (modelX, tokenWidth) => {\n      const xCoordOfColumn = columnNr => {\n        return (\n          props.margin +\n          (columnNr - 1 + 0.5) * (props.width / props.columnCount) -\n          tokenWidth / 2\n        );\n      };\n\n      if (modelX < 1) {\n        return (\n          UNCREATED_COLUMN_X + modelX * (xCoordOfColumn(1) - UNCREATED_COLUMN_X)\n        );\n      } else {\n        return xCoordOfColumn(modelX);\n      }\n    },\n    [props.margin, props.width, props.columnCount]\n  );\n\n  // Set function on Move to give the y coordinate on the canvas of a vertical slot #\n  // Assuming slot numbering starts from 0\n  const slotToYCoord = slot => {\n    return slot * TOKEN_HEIGHT;\n  };\n\n  Story.prototype.getTokenWidth = () =>\n    props.stories.maxTokenStringWidth + 1.2 * TOKEN_HEIGHT;\n\n  const handlePopupClose = () => {\n    setSelectedStory(undefined);\n  };\n\n  const storyTokensStyle = {\n    position: 'relative',\n  };\n\n  //  useEffect(() => {\n  //    console.log('updateTokensAtAnimationTime');\n  props.stories.updateTokensAtAnimationTime(props.animationTime);\n  //  }, [props.animationTime, props.stories]);\n\n  return (\n    <div id=\"story-tokens\" style={storyTokensStyle}>\n      {props.stories.asArray().map(story => (\n        <StoryToken\n          story={story}\n          columnToXCoord={columnToXCoord}\n          slotToYCoord={slotToYCoord}\n          key={story.id}\n          animationTime={props.animationTime}\n          selected={selectedStory === story}\n          setSelectedStory={setSelectedStory}\n        />\n      ))}\n      <StoryPopup\n        story={selectedStory}\n        handleClose={handlePopupClose}\n        windowDimensions={props.windowDimensions}\n      />\n    </div>\n  );\n}\n\nfunction StoryToken(props) {\n  const appearance = props.story.getAppearanceAtAnimationTime(\n    props.animationTime\n  );\n\n  const tokenWidth = props.story.getTokenWidth();\n  const left = props.columnToXCoord(props.story.modelX, tokenWidth);\n  const bottom = props.slotToYCoord(props.story.modelY);\n\n  const tokenCommonStyle = {\n    position: 'absolute',\n    left: left,\n    bottom: bottom,\n    width: tokenWidth,\n    font: TOKEN_FONT,\n    borderRadius: TOKEN_HEIGHT / 2,\n    border: 'solid',\n    backgroundColor: appearance.fillColor,\n    color: appearance.fontColor,\n    opacity: appearance.opacity,\n    overflow: 'hidden',\n    textOverflow: 'ellipsis',\n    padding: '1px',\n    cursor: 'pointer',\n    boxSizing: 'borderBox',\n  };\n\n  const tokenUnSelectedStyle = {\n    borderWidth: '1px',\n    borderColor: '#111',\n    zIndex: 1,\n  };\n\n  const tokenSelectedStyle = {\n    borderWidth: '2px',\n    borderColor: '#FD0',\n    zIndex: 2,\n  };\n\n  const tokenSelectionStyle = props.selected\n    ? tokenSelectedStyle\n    : tokenUnSelectedStyle;\n\n  const handleClick = () => {\n    if (!props.selected) {\n      props.setSelectedStory(props.story);\n    } else {\n      props.setSelectedStory(null);\n    }\n  };\n\n  return (\n    <div\n      key={props.story.id}\n      style={{ ...tokenCommonStyle, ...tokenSelectionStyle }}\n      onClick={handleClick}\n    >\n      {props.story.id}\n    </div>\n  );\n}\n\nexport default memo(StoryTokens);\n","/Users/fredrik/dev/flowanimator/client/src/data-area.js",["137"],"import React, { memo } from 'react';\nimport './data-area.css';\n\nfunction DataArea(props) {\n  const dataAreaStyle = {\n    marginLeft: props.margin,\n    marginRight: props.margin,\n    flex: 0,\n    minHeight: '80px',\n    padding: '0px',\n  };\n\n  return (\n    <div id=\"data-area\" style={dataAreaStyle}>\n      <AnimationTimeDisplay\n        animationTime={props.animationTime}\n        animationTimeToCalendarDate={\n          props.animationData.animationTimeToCalendarDate\n        }\n      />\n    </div>\n  );\n}\n\nfunction AnimationTimeDisplay(props) {\n  const animationTime = new Date(props.animationTime)\n    .toISOString()\n    .slice(11, 19);\n  //https://stackoverflow.com/questions/29816872/how-can-i-convert-milliseconds-to-hhmmss-format-using-javascript\n  const animatedDate = new Intl.DateTimeFormat('fi-FI', {\n    day: 'numeric',\n    month: 'numeric',\n    year: 'numeric',\n  }).format(new Date(props.animationTimeToCalendarDate(props.animationTime)));\n\n  return (\n    <div id=\"animation-time-display\" className=\"data-box\">\n      {animationTime} <br />\n      {animatedDate}\n    </div>\n  );\n}\n\n/*\nfunction SelectedStoryDetails(props) {\n  if (props.selectedStory) {\n    return (\n      <div className=\"data-box\">\n        <div id=\"selected-story-details\">\n          {props.selectedStory.id} {props.selectedStory.name}\n          <br />\n          Created: {props.selectedStory.created}\n          <br />\n          Creator: {props.selectedStory.creator}\n        </div>\n      </div>\n    );\n  } else {\n    return <div className=\"data-box\" />;\n  }\n}\n\n\n  if (props.selectedStory) {\n    return (\n      <div id=\"selected-story-details\" style={selectedStoryDetailsStyle}>\n        {props.selectedStory.id} <br />\n        {props.selectedStory.name}\n      </div>\n    );\n  } else {\n    return <div />;\n  }\n}\n*/\n\nexport default memo(DataArea);\n","/Users/fredrik/dev/flowanimator/client/src/autocomplete.js",["138"],"import React, { Component, Fragment } from 'react';\nimport { TextInput } from './controls.js';\n// import PropTypes from 'prop-types';\n\n// Based on https://alligator.io/react/react-autocomplete/\n\nclass Autocomplete extends Component {\n  // static propTypes = {\n  //   suggestions: PropTypes.instanceOf(Array),\n  //   tabIndex: PropTypes.instanceOf(Number),\n  //   label: PropTypes.instanceOf(String),\n  // };\n\n  static defaultProps = {\n    suggestions: [],\n    tabIndex: 0,\n    label: '',\n    placeholder: '',\n  };\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      // The active selection's index\n      activeSuggestion: -1,\n      // The suggestions that match the user's input\n      filteredSuggestions: [],\n      // Whether or not the suggestion list is shown\n      showSuggestions: false,\n      // What the user has entered\n      userInput: '',\n      inputFieldValue: '',\n      selectedValue: '',\n    };\n\n    this.suggestionListRef = React.createRef();\n  }\n\n  // Event fired when the input is selected or the input value is changed\n  onFocusOrChange = e => {\n    const { suggestions } = this.props;\n    const userInput = e.currentTarget.value;\n\n    // Filter our suggestions that don't contain the user's input\n    const filteredSuggestions = suggestions.filter(\n      suggestion =>\n        suggestion.toLowerCase().indexOf(userInput.toLowerCase()) > -1\n    );\n\n    // set Selected Value to the user input in case the input corresponds to\n    // one of the valid alternatives\n\n    const selectedValue = filteredSuggestions.includes(userInput)\n      ? userInput\n      : '';\n    // if Selected Value changed, call the event handler\n    if (selectedValue !== this.state.selectedValue) {\n      this.props.onValueChange(selectedValue);\n    }\n\n    // Update the user input and filtered suggestions, reset the active\n    // suggestion, make sure the suggestions are shown\n\n    this.setState({\n      filteredSuggestions,\n      showSuggestions: true,\n      userInput: userInput,\n      inputFieldValue: userInput,\n      selectedValue: selectedValue,\n    });\n  };\n\n  onBlur = e => {\n    setTimeout(() => {\n      this.setState({\n        showSuggestions: false,\n      });\n    }, 150);\n  };\n\n  // Event fired when the user clicks on a suggestion\n  onMouseDown = e => {\n    const selectedValue = e.currentTarget.innerText;\n    // if Selected Value changed, call the event handler\n    if (selectedValue !== this.state.selectedValue) {\n      this.props.onValueChange(selectedValue);\n    }\n    // Update the user input and reset the rest of the state\n    this.setState({\n      filteredSuggestions: [],\n      showSuggestions: false,\n      inputFieldValue: selectedValue,\n      selectedValue: selectedValue,\n    });\n  };\n\n  onMouseOver = e => {\n    const { filteredSuggestions } = this.state;\n    // Update the user input and reset the rest of the state\n    this.setState({\n      activeSuggestion: filteredSuggestions.indexOf(e.currentTarget.innerText),\n    });\n  };\n\n  onMouseOut = e => {\n    this.setState({\n      activeSuggestion: -1,\n    });\n  };\n\n  // Event fired when the user presses a key down\n  onKeyDown = e => {\n    const { activeSuggestion, filteredSuggestions, userInput } = this.state;\n    switch (e.keyCode) {\n      // User pressed the tab or enter key, update the input and close the\n      // suggestions\n      case 9:\n      case 13:\n        this.setState({\n          activeSuggestion: -1,\n          showSuggestions: false,\n        });\n        break;\n      // User pressed the down arrow, increment the index\n      case 40:\n        if (activeSuggestion < filteredSuggestions.length - 1) {\n          const selectedSuggestion = activeSuggestion + 1;\n          const selectedValue = filteredSuggestions[selectedSuggestion];\n          // if Selected Value changed, call the event handler\n          if (selectedValue !== this.state.selectedValue) {\n            this.props.onValueChange(selectedValue);\n          }\n          this.setState({\n            activeSuggestion: selectedSuggestion,\n            inputFieldValue: selectedValue,\n            selectedValue: selectedValue,\n          });\n        }\n        break;\n      // User pressed the up arrow, decrement the index\n      case 38:\n        if (activeSuggestion >= 1) {\n          const selectedSuggestion = activeSuggestion - 1;\n          const selectedValue = filteredSuggestions[selectedSuggestion];\n          // if Selected Value changed, call the event handler\n          if (selectedValue !== this.state.selectedValue) {\n            this.props.onValueChange(selectedValue);\n          }\n          this.setState({\n            activeSuggestion: selectedSuggestion,\n            inputFieldValue: selectedValue,\n            selectedValue: selectedValue,\n          });\n          // If we scrolled up out of the suggestion list\n        } else if (activeSuggestion === 0) {\n          // set Selected Value to the user input in case the input corresponds to\n          // one of the valid alternatives\n\n          const selectedValue = filteredSuggestions.includes(\n            this.state.userInput\n          )\n            ? this.state.userInput\n            : '';\n          // if Selected Value changed, call the event handler\n          if (selectedValue !== this.state.selectedValue) {\n            this.props.onValueChange(selectedValue);\n          }\n\n          this.setState({\n            activeSuggestion: -1,\n            inputFieldValue: userInput,\n            selectedValue: selectedValue,\n          });\n        }\n\n        break;\n\n      default:\n    }\n  };\n\n  render() {\n    const {\n      onFocusOrChange,\n      onBlur,\n      onMouseDown,\n      onMouseOver,\n      onMouseOut,\n      onKeyDown,\n      state: {\n        activeSuggestion,\n        filteredSuggestions,\n        showSuggestions,\n        inputFieldValue,\n      },\n    } = this;\n\n    const { tabIndex, label, placeholder } = this.props;\n\n    let suggestionsListComponent;\n\n    if (showSuggestions) {\n      if (filteredSuggestions.length) {\n        suggestionsListComponent = (\n          <ul\n            className=\"suggestions\"\n            onMouseOut={onMouseOut}\n            ref={this.suggestionListRef}\n          >\n            {filteredSuggestions.map((suggestion, index) => {\n              // Flag the active suggestion with a class\n              return (\n                <li\n                  className={\n                    index === activeSuggestion ? 'suggestion-active' : ''\n                  }\n                  key={suggestion}\n                  id={replaceIllegalSelectorChars(suggestion)}\n                  onMouseDown={onMouseDown}\n                  onMouseOver={onMouseOver}\n                  tabIndex=\"-1\"\n                >\n                  {suggestion}\n                </li>\n              );\n            })}\n          </ul>\n        );\n      } else {\n        suggestionsListComponent = (\n          <div className=\"no-suggestions\">\n            <em>No board found that matches your search string.</em>\n          </div>\n        );\n      }\n    }\n\n    return (\n      <Fragment>\n        <TextInput\n          label={label}\n          placeholder={placeholder}\n          tabIndex={tabIndex}\n          type=\"text\"\n          id=\"inpBoard\"\n          value={inputFieldValue}\n          onChange={onFocusOrChange}\n          onFocus={onFocusOrChange}\n          onBlur={onBlur}\n          onKeyDown={onKeyDown}\n        />\n        {suggestionsListComponent}\n      </Fragment>\n    );\n  }\n}\n\nfunction replaceIllegalSelectorChars(str) {\n  return str.replace(/^[\\d-]/g, 'Z').replace(/[^a-zA-Z\\d_-]/g, 'z');\n}\n\nexport default Autocomplete;\n","/Users/fredrik/dev/flowanimator/client/src/css-spinner.js",["139"],"import React from 'react';\nimport './css-spinner.css';\n\n// Based on https://tobiasahlin.com/spinkit/\n\nexport default function CssSpinner(props) {\n  if (props.visible) {\n    return (\n      <div className=\"sk-fading-circle\">\n        <div className=\"sk-circle1 sk-circle\" />\n        <div className=\"sk-circle2 sk-circle\" />\n        <div className=\"sk-circle3 sk-circle\" />\n        <div className=\"sk-circle4 sk-circle\" />\n        <div className=\"sk-circle5 sk-circle\" />\n        <div className=\"sk-circle6 sk-circle\" />\n      </div>\n    );\n  } else {\n    return <div />;\n  }\n}\n","/Users/fredrik/dev/flowanimator/client/src/move.js",["140"],"/**\n * @file src/move.js\n * @description TODO\n */\n\n// const OVERLAP_TIME = 100;\n\nexport function Move(\n  story,\n  type,\n  start,\n  duration,\n  fromColumn,\n  toColumn,\n  fromSlot,\n  toSlot\n) {\n  this.story = story;\n  this.type = type;\n  this.id = story.id;\n  this.start = start;\n  this.duration = duration;\n  this.end = start + duration; // TODO: end and duration redundant\n  this.fromColumn = fromColumn;\n  this.toColumn = toColumn;\n  this.fromSlot = fromSlot;\n  this.toSlot = toSlot;\n  this.next = undefined;\n  this.previous = undefined;\n}\n\nexport function MovesCollection() {\n  this.count = 0;\n  this.first = undefined;\n  this.last = undefined;\n  this.activeMoves = { head: undefined, moves: {} };\n\n  this.push = move => {\n    if (this.count === 0) {\n      this.first = move;\n      this.last = move;\n    } else {\n      this.last.next = move;\n      move.previous = this.last;\n      this.last = move;\n    }\n    this.count++;\n  };\n\n  this.addToActiveMoves = move => {\n    this.activeMoves.moves[move.story.id] = move;\n    this.activeMoves.head = move;\n  };\n\n  this.removeFromActiveMoves = move => {\n    delete this.activeMoves.moves[move.story.id];\n  };\n\n  this.getActiveMoves = function*() {\n    for (var moveId in this.activeMoves.moves) {\n      yield this.activeMoves.moves[moveId];\n    }\n  };\n\n  this.clear = () => {\n    this.first = undefined;\n    this.last = undefined;\n    this.activeMoves = { head: undefined, moves: {} };\n    this.count = 0;\n  };\n}\n\n/*\nexport function Timeline() {\n  const INITIAL_INTERVAL = 15;\n\n  this.movesInAscendingOrder = [];\n  this.movesInDescendingOrder = [];\n  const interval = INITIAL_INTERVAL;\n  // this.moves = [];\n  this.time = 0;\n  this.previousTime = 0;\n  this.endTime = 0;\n  // this.onTimeHandler = {};\n  this.playing = false;\n\n  this.addMove = (\n    story,\n    type,\n    start,\n    duration,\n    fromColumn,\n    toColumn,\n    fromSlot,\n    toSlot\n  ) => {\n    const move = new Move(\n      story,\n      type,\n      start,\n      duration,\n      fromColumn,\n      toColumn,\n      fromSlot,\n      toSlot\n    );\n    // this.moves.push(move);\n    this.movesInAscendingOrder.push(move);\n    this.movesInDescendingOrder.unshift(move);\n    story.addMove(start, duration, fromColumn, toColumn, fromSlot, toSlot); // TODO: no longer necessary?\n    this.endTime = Math.max(start + duration, this.endTime);\n  };\n\n  /* this.updateTokensAtAnimationMoment = animationMoment => {\n    const movesActiveAtAnimationMoment = moves.filter(move => {\n      return (\n        move.start <= animationMoment &&\n        move.start + move.duration >= animationMoment - OVERLAP_TIME\n      );\n    });\n\n    movesActiveAtAnimationMoment.forEach(move => {\n      move.moveTokenToPositionAtAnimationMoment(animationMoment);\n    });\n  };*/\n/*\n  this.setEventHandler = eventHandler => {\n    this.eventHandler = eventHandler;\n  };\n\n  const executeInterval = (functionToExecute, delay, keepGoing, whenDone) => {\n    if (keepGoing()) {\n      functionToExecute().then(response => {\n        if (!response.animationDone) {\n          setTimeout(\n            () =>\n              executeInterval(functionToExecute, delay, keepGoing, whenDone),\n            delay\n          );\n        } else {\n          whenDone();\n        }\n      });\n    }\n  };\n\n  this.play = () => {\n    this.playing = true;\n    executeInterval(\n      timelineTick,\n      interval,\n      shouldAnimationContinue,\n      animationCompleted\n    );\n  };\n\n  const timelineTick = async () => {\n    this.processTimelineEvent();\n    this.previousTime = this.time;\n    this.time += interval;\n    const animationDone = this.time > this.endTime;\n    return { animationDone: animationDone };\n  };\n\n  const shouldAnimationContinue = () => {\n    return this.playing;\n  };\n\n  const animationCompleted = () => {\n    this.processTimelineEvent();\n    this.playing = false;\n    this.previousTime = this.time;\n    this.time = 0;\n  };\n\n  this.pause = () => {\n    this.playing = false;\n  };\n\n  this.stop = () => {\n    this.playing = false;\n    this.time = 0;\n    this.previousTime = 0;\n    this.processTimelineEvent();\n  };\n\n  this.processTimelineEvent = () => {\n    const selectedMoves = {};\n\n    if (this.time > this.previousTime) {\n      for (let i = 0; i < this.movesInAscendingOrder.length; i++) {\n        const move = this.movesInAscendingOrder[i];\n        if (move.start < this.time) {\n          if (move.end > this.previousTime) {\n            selectedMoves[move.story.id] = move; // this will overwrite any previously registered moves of the same story; this is done since we want to pick the last move of the story if there are several falling within the interval\n          }\n        } else {\n          break;\n        }\n      }\n    } else {\n      for (let i = 0; i < this.movesInDescendingOrder.length; i++) {\n        const move = this.movesInDescendingOrder[i];\n        if (move.end > this.time) {\n          if (move.start < this.previousTime) {\n            selectedMoves[move.story.id] = move; // this will overwrite any previously registered moves of the same story; this is done since we want to pick the first move of the story if there are several falling within the interval\n          }\n        } else {\n          break;\n        }\n      }\n    }\n\n    for (var storyId in selectedMoves) {\n      selectedMoves[storyId].moveTokenToPositionAtAnimationMoment(this.time);\n    }\n\n    // Execute external event handler\n    this.eventHandler(\n      new TimelineEvent(this.time, this.getProgress(), this.isDone())\n    );\n  };\n\n  this.getProgress = () => {\n    return this.time / this.endTime;\n  };\n\n  this.getEndTime = () => {\n    return this.endTime;\n  };\n\n  this.isDone = () => {\n    return this.time > this.endTime;\n  };\n\n  this.speed = speed => {\n    // TODO\n    return 1;\n  };\n\n  this.setTime = time => {\n    this.previousTime = this.time;\n    this.time = Math.max(Math.min(time, this.endTime), 0);\n    this.processTimelineEvent();\n  };\n\n  this.clear = () => {\n    this.movesInAscendingOrder.length = 0;\n    this.movesInDescendingOrder.length = 0;\n    this.time = 0;\n    this.previousTime = 0;\n    this.endTime = 0;\n    this.playing = false;\n  };\n\n  this.sort = () => {\n    this.movesInAscendingOrder.sort((move1, move2) => {\n      if (move1.start < move2.start) {\n        return -1;\n      } else if (move1.start > move2.start) {\n        return 1;\n      } else {\n        return 0;\n      }\n    });\n\n    this.movesInDescendingOrder.sort((move1, move2) => {\n      if (move1.end > move2.end) {\n        return -1;\n      } else if (move1.end < move2.end) {\n        return 1;\n      } else {\n        return 0;\n      }\n    });\n  };\n\n  /*\n  pause;\n  stop;\n  time;\n  speed;\n  */\n","/Users/fredrik/dev/flowanimator/client/src/transition.js",["141"],"/**\n * @file src/transition.js\n * @description Defines the {@link Transition} class for representing the\n * status transition of an issue and the {@link TransitionCollection} class for\n * holding all the status transitions of the currently loaded project.\n */\n\nimport {\n  TRANSITION_IN_CALENDAR_TIME,\n  calendarDaysToAnimationTime,\n} from './animation-data.js';\n\n/**\n * @constructor Transition\n * @description Constructor for objects to represent the status transitions\n * in the current project\n */\nexport function Transition(\n  story,\n  fromColumn,\n  toColumn,\n  timestamp,\n  transitionStartDateTime\n) {\n  this.story = story;\n  this.fromColumn = fromColumn;\n  this.toColumn = toColumn;\n  this.timestamp = timestamp;\n  this.date = new Intl.DateTimeFormat('fi-FI', {\n    day: 'numeric',\n    month: 'numeric',\n    year: 'numeric',\n  }).format(new Date(timestamp));\n  this.transitionStartDateTime = transitionStartDateTime;\n\n  // /* console.log(new Date(this.timestamp).toISOString()); */\n\n  this.getTimeStamp = function() {\n    return this.timeStamp.getTime();\n  };\n\n  this.getTransitionStartDateTime = () => {\n    return this.transitionStartDateTime;\n  };\n\n  this.getTransitionStartOnTimeline = () => {\n    if (\n      // these are not set in the constructor but only later on from within animation.js, so better check for their presence to be sure\n      this.getFirstTransitionDate\n    ) {\n      return calendarDaysToAnimationTime(\n        this.getTransitionStartDateTime() - this.getFirstTransitionDate()\n      );\n    }\n  };\n\n  this.getDurationInCalendarTime = () => {\n    return TRANSITION_IN_CALENDAR_TIME;\n  };\n}\n\n/**\n * @constructor TransitionCollection\n * @description Constructor for the for the TransitionCollection object\n * holding all the status transitions of the currently loaded project.\n */\nexport function TransitionCollection() {\n  this.transitions = [];\n\n  this.push = transition => {\n    this.transitions.push(transition);\n  };\n\n  this.addTransitions = transitionsToAdd => {\n    this.transitions = this.transitions.concat(transitionsToAdd);\n  };\n\n  this.clear = function() {\n    this.transitions.length = 0;\n    this.transitions = []; // TODO what is the most appropriate way to clear an array?\n    /* console.log('**************** transitionCollection cleared!'); */\n  };\n\n  Transition.prototype.getSortOrder = (firstTransition, secondTransition) => {\n    if (\n      firstTransition.transitionStartDateTime <\n      secondTransition.transitionStartDateTime\n    ) {\n      return -1;\n    } else if (\n      firstTransition.transitionStartDateTime >\n      secondTransition.transitionStartDateTime\n    ) {\n      return 1;\n    } else {\n      // Same timestamp, need some other way to determine the sort order\n      if (firstTransition.story === secondTransition.story) {\n        // Same timestamp, case 1:\n        // Same issue transitioning over several columns at the same time,\n        // sorting according to the sequence of the columns transitioned into\n        if (\n          firstTransition.toColumn.number < secondTransition.toColumn.number\n        ) {\n          return -1;\n        } else {\n          return 1;\n        }\n      } else {\n        // Same timestamp, case 2:\n        // Different issues transitioning at the same time,\n        // sort order is arbitrary but result should be conistent,\n        // sorting according to the alphabetic order of the issue id:s\n        return firstTransition.story.id.localeCompare(\n          secondTransition.story.id\n        );\n      }\n    }\n  };\n\n  this.sort = function() {\n    this.transitions.sort(Transition.prototype.getSortOrder);\n  };\n\n  this.getFirstTransitionDate = () => {\n    return this.transitions[0].transitionStartDateTime;\n  };\n\n  this.getLastTransitionDate = () => {\n    return this.transitions[this.transitions.length - 1]\n      .transitionStartDateTime;\n  };\n\n  this.getTimespan = function() {\n    return this.getLastTransitionDate() - this.getFirstTransitionDate();\n  };\n\n  this.getIterator = function*() {\n    for (var transition of this.transitions) {\n      yield transition;\n    }\n  };\n}\n","/Users/fredrik/dev/flowanimator/client/src/utils.js",["142"],"const DATE_FORMAT = 'dd.mm.yyyy'; // TODO move this into a proper settings object\nconst DATE_TIME_FORMAT = 'dd.mm.yyyy'; // TODO move this into a proper settings object\n\nexport function shareOfIntervalCovered(point, intervalStart, intervalEnd) {\n  return (\n    Math.max(Math.min(point, intervalEnd) - intervalStart, 0) /\n    (intervalEnd - intervalStart)\n  );\n}\n\nexport function amountOfIntervalCovered(point, intervalStart, intervalEnd) {\n  return Math.max(Math.min(point, intervalEnd) - intervalStart, 0);\n}\n\nexport const utils = {\n  /****************************************************************************\n                                setIntervalAsync\n ****************************************************************************/\n\n  setIntervalAsync: function executeIntervalAsync(\n    fn,\n    delay,\n    progressCallback,\n    completionCallback\n  ) {\n    fn().then(response => {\n      if (!response.done) {\n        progressCallback(response.value);\n        setTimeout(\n          () =>\n            executeIntervalAsync(\n              fn,\n              delay,\n              progressCallback,\n              completionCallback\n            ),\n          delay\n        );\n      } else {\n        completionCallback();\n      }\n    });\n  },\n\n  /****************************************************************************\n                                stringToDate\n ****************************************************************************/\n\n  stringToDate: date => {\n    var format = DATE_FORMAT;\n    // eliminating possible time component for now\n    date = date.split(' ')[0];\n    date = date.split('T')[0];\n    format = format.split(' ')[0];\n    format = format.split('T')[0];\n\n    const delimiter = format.match(/\\W/g)[0];\n    const formatLowerCase = format.toLowerCase();\n    const formatItems = formatLowerCase.split(delimiter);\n    const dateItems = date.split(delimiter);\n    const monthIndex = formatItems.indexOf('mm');\n    const dayIndex = formatItems.indexOf('dd');\n    const yearIndex = formatItems.indexOf('yyyy');\n    const formattedDate = new Date(\n      dateItems[yearIndex],\n      dateItems[monthIndex] - 1,\n      dateItems[dayIndex]\n    );\n\n    // const formattedDate = new Date(Date.parse(date));\n\n    return formattedDate;\n  },\n\n  /****************************************************************************\n                                stringToDateTime\n ****************************************************************************/\n\n  stringToDateTime: dateTime => {\n    var dateTimeformat = DATE_TIME_FORMAT;\n\n    var timePartDelimiter = null;\n    if (dateTimeformat.match(/T/)) {\n      timePartDelimiter = 'T';\n    } else {\n      if (dateTimeformat.match(/\\x20/)) {\n        timePartDelimiter = ' ';\n      }\n    }\n\n    var dateFormat;\n    var timeFormat;\n    var date;\n    var time;\n    var formattedDateTime;\n\n    if (timePartDelimiter) {\n      dateFormat = dateTimeformat.split(timePartDelimiter)[0];\n      timeFormat = dateTimeformat.split(timePartDelimiter)[1];\n      date = dateTime.split(timePartDelimiter)[0];\n      time = dateTime.split(timePartDelimiter)[1];\n    } else {\n      dateFormat = dateTimeformat;\n      date = dateTime;\n    }\n\n    const dateDelimiter = dateFormat.match(/\\W/g)[0];\n    const dateFormatLowerCase = dateFormat.toLowerCase();\n    const dateFormatItems = dateFormatLowerCase.split(dateDelimiter);\n    const dateItems = date.split(dateDelimiter);\n    const monthIndex = dateFormatItems.indexOf('mm');\n    const dayIndex = dateFormatItems.indexOf('dd');\n    const yearIndex = dateFormatItems.indexOf('yyyy');\n\n    if (timePartDelimiter) {\n      const timeDelimiter = timeFormat.match(/\\W/g)[0];\n      const timeFormatLowerCase = timeFormat.toLowerCase();\n      const timeFormatItems = timeFormatLowerCase.split(timeDelimiter);\n      const timeItems = time.split(timeDelimiter);\n      const hourIndex = timeFormatItems.indexOf('hh');\n      const minuteIndex = timeFormatItems.indexOf('mm');\n      const secondIndex = timeFormatItems.indexOf('ss');\n      formattedDateTime = new Date(\n        dateItems[yearIndex],\n        dateItems[monthIndex] - 1,\n        dateItems[dayIndex],\n        timeItems[hourIndex],\n        timeItems[minuteIndex],\n        timeItems[secondIndex]\n      );\n    } else {\n      formattedDateTime = new Date(\n        dateItems[yearIndex],\n        dateItems[monthIndex] - 1,\n        dateItems[dayIndex]\n      );\n    }\n\n    return formattedDateTime;\n  },\n\n  /****************************************************************************\n                               msToTime\n ****************************************************************************/\n\n  msToTime: durationInMs => {\n    // thanks to https://coderwall.com/p/wkdefg/converting-milliseconds-to-hh-mm-ss-mmm\n    const milliseconds = parseInt(durationInMs) % 1000;\n    var seconds = (parseInt(durationInMs) / 1000) % 60;\n    var minutes = (parseInt(durationInMs) / (1000 * 60)) % 60;\n    var hours = (parseInt(durationInMs) / (1000 * 60 * 60)) % 24;\n    const days = parseInt(durationInMs) / (1000 * 60 * 60 * 24);\n\n    hours = hours < 10 ? '0' + hours : hours;\n    minutes = minutes < 10 ? '0' + minutes : minutes;\n    seconds = seconds < 10 ? '0' + seconds : seconds;\n\n    var timeStr = hours + ':' + minutes + ':' + seconds + '.' + milliseconds;\n    if (days > 0) {\n      timeStr = days + 'd' + timeStr;\n    }\n\n    return timeStr;\n  },\n\n  /****************************************************************************\n                               msToDays\n ****************************************************************************/\n\n  msToDays: durationInMs => {\n    // thanks to https://coderwall.com/p/wkdefg/converting-milliseconds-to-hh-mm-ss-mmm\n    // const hours = Math.trunc((durationInMs / (1000 * 60 * 60)) % 24);\n    const days = Math.round(durationInMs / (1000 * 60 * 60 * 24));\n\n    return days + ' d ';\n  },\n};\n\nexport function measureStringWidth(string, font) {\n  // https://stackoverflow.com/questions/5353385/how-to-calculate-the-length-in-pixels-of-a-string-in-javascript\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d');\n  ctx.font = font; // \"11px Arial\"\n  const width = ctx.measureText(string).width;\n  canvas.remove();\n  return width;\n}\n\n/*\nfunction saveJSON(data) {\n  let bl = new Blob([JSON.stringify(data)], {\n    type: 'application/json',\n  });\n  let a = document.createElement('a');\n  a.href = URL.createObjectURL(bl);\n  a.download = 'data.json';\n  a.hidden = true;\n  document.body.appendChild(a);\n  a.innerHTML = 'someinnerhtml';\n  a.click();\n}\n*/\n","/Users/fredrik/dev/flowanimator/client/src/story-popup.js",["143"],"import React, { memo, useRef, useState } from 'react';\nimport './story-popup.css';\n\nfunction StoryPopup(props) {\n  const POPUP_WIDTH = 250;\n\n  const startX = props.windowDimensions.windowWidth / 2 - POPUP_WIDTH / 2;\n  const startY = props.windowDimensions.windowHeight / 4;\n\n  const [x, setX] = useState(startX);\n  const [y, setY] = useState(startY);\n  const [dragStartX, _setDragStartX] = useState(0);\n  const [dragStartY, _setDragStartY] = useState(0);\n\n  // https://medium.com/geographit/accessing-react-state-in-event-listeners-with-usestate-and-useref-hooks-8cceee73c559\n  const dragStartXRef = useRef(dragStartX);\n  const dragStartYRef = useRef(dragStartY);\n\n  const setDragStartX = x => {\n    _setDragStartX(x);\n    dragStartXRef.current = x;\n  };\n\n  const setDragStartY = y => {\n    _setDragStartY(y);\n    dragStartYRef.current = y;\n  };\n\n  const popupStyle = {\n    left: x,\n    top: y,\n    width: POPUP_WIDTH + 'px',\n  };\n\n  const handleStartDrag = event => {\n    console.log('Set dragStartX to ' + event.clientX);\n    setDragStartX(event.clientX);\n    setDragStartY(event.clientY);\n    document.addEventListener('mousemove', handleDrag);\n    document.addEventListener('mouseup', handleDragEnd);\n  };\n\n  const handleDrag = event => {\n    setX(oldX => {\n      return oldX + event.clientX - dragStartXRef.current;\n    });\n    setY(oldY => {\n      return oldY + event.clientY - dragStartYRef.current;\n    });\n    setDragStartX(event.clientX);\n    setDragStartY(event.clientY);\n  };\n\n  const handleDragEnd = event => {\n    document.removeEventListener('mousemove', handleDrag);\n    document.removeEventListener('mouseup', handleDragEnd);\n  };\n\n  if (props.story) {\n    return (\n      <div id=\"story-popup\" style={popupStyle} onMouseDown={handleStartDrag}>\n        <PopupHeader onClick={props.handleClose} />\n        <PopupBody story={props.story} />\n      </div>\n    );\n  } else {\n    return null;\n  }\n}\n\nfunction PopupHeader(props) {\n  return (\n    <div className=\"popup-header\">\n      <span id=\"btnPopupClose\" onClick={props.onClick}>\n        &times;\n      </span>\n    </div>\n  );\n}\n\nfunction StaysInStatus(props) {\n  return (\n    <table class=\"popup-table\">\n      <thead>\n        <tr>\n          <th className=\"column-1\">Status</th>\n          <th>Entered</th>\n          <th className=\"column-3\">Days in status</th>\n        </tr>\n      </thead>\n\n      <tbody>\n        {props.story.getStatusStays().map(statusStay => (\n          <tr key={statusStay.id}>\n            <td className=\"column-1\">\n              <div>{statusStay.status}</div>\n            </td>\n            <td className=\"column-2\">{statusStay.date}</td>\n            <td className=\"column-3\">{statusStay.days}</td>\n          </tr>\n        ))}\n      </tbody>\n    </table>\n  );\n}\n\nfunction PopupBody(props) {\n  const completedDate = props.story.fields.resolutiondate\n    ? new Intl.DateTimeFormat('fi-FI', {\n        day: 'numeric',\n        month: 'numeric',\n        year: 'numeric',\n      }).format(new Date(props.story.fields.resolutiondate))\n    : '';\n\n  return (\n    <div className=\"popup-body\">\n      <a\n        id=\"popup-key\"\n        href={props.story.url}\n        target=\"_blank\"\n        rel=\"noopener noreferrer\"\n      >\n        {props.story.id}\n      </a>\n      <div id=\"popup-summary\">{props.story.fields.summary}</div>\n      <table class=\"popup-table\">\n        <tbody>\n          <tr>\n            <td className=\"first-column\">Type:</td>\n            <td>{props.story.fields.issuetype.name}</td>\n          </tr>\n          <tr>\n            <td>Created by:</td>\n            <td>{props.story.fields.creator.displayName}</td>\n          </tr>\n          <tr>\n            <td>Created:</td>\n            <td>{props.story.getCreatedDate()}</td>\n          </tr>\n          <tr>\n            <td>Completed:</td>\n            <td>{completedDate}</td>\n          </tr>\n          <tr>\n            <td>Cycle time:</td>\n            <td>{props.story.getCycleTime()}</td>\n          </tr>\n          <tr>\n            <td>Lead time:</td>\n            <td>{props.story.getLeadTime()}</td>\n          </tr>\n        </tbody>\n      </table>\n      <StaysInStatus story={props.story} />\n    </div>\n  );\n}\n\nexport default memo(StoryPopup);\n",{"ruleId":null,"fatal":true,"severity":2,"message":"144"},{"ruleId":"145","replacedBy":"146"},{"ruleId":"147","replacedBy":"148"},{"ruleId":"149","replacedBy":"150"},{"ruleId":null,"fatal":true,"severity":2,"message":"144"},{"ruleId":null,"fatal":true,"severity":2,"message":"144"},{"ruleId":null,"fatal":true,"severity":2,"message":"144"},{"ruleId":null,"fatal":true,"severity":2,"message":"144"},{"ruleId":null,"fatal":true,"severity":2,"message":"144"},{"ruleId":null,"fatal":true,"severity":2,"message":"144"},{"ruleId":null,"fatal":true,"severity":2,"message":"144"},{"ruleId":null,"fatal":true,"severity":2,"message":"144"},{"ruleId":null,"fatal":true,"severity":2,"message":"144"},{"ruleId":null,"fatal":true,"severity":2,"message":"144"},{"ruleId":null,"fatal":true,"severity":2,"message":"144"},{"ruleId":null,"fatal":true,"severity":2,"message":"144"},{"ruleId":null,"fatal":true,"severity":2,"message":"144"},{"ruleId":null,"fatal":true,"severity":2,"message":"144"},{"ruleId":null,"fatal":true,"severity":2,"message":"144"},{"ruleId":null,"fatal":true,"severity":2,"message":"144"},{"ruleId":null,"fatal":true,"severity":2,"message":"144"},{"ruleId":null,"fatal":true,"severity":2,"message":"144"},{"ruleId":null,"fatal":true,"severity":2,"message":"144"},{"ruleId":null,"fatal":true,"severity":2,"message":"144"},{"ruleId":null,"fatal":true,"severity":2,"message":"144"},{"ruleId":null,"fatal":true,"severity":2,"message":"144"},"Parsing error: Cannot find module './builders/flow/createUnionTypeAnnotation'\nRequire stack:\n- /Users/fredrik/dev/flowanimator/client/node_modules/@babel/types/lib/index.js\n- /Users/fredrik/dev/flowanimator/client/node_modules/babel-eslint/lib/visitor-keys.js\n- /Users/fredrik/dev/flowanimator/client/node_modules/babel-eslint/lib/parse-with-scope.js\n- /Users/fredrik/dev/flowanimator/client/node_modules/babel-eslint/lib/index.js\n- /usr/local/lib/node_modules/react-scripts/node_modules/@eslint/eslintrc/lib/config-array-factory.js\n- /usr/local/lib/node_modules/react-scripts/node_modules/@eslint/eslintrc/lib/index.js\n- /usr/local/lib/node_modules/react-scripts/node_modules/eslint/lib/cli-engine/cli-engine.js\n- /usr/local/lib/node_modules/react-scripts/node_modules/eslint/lib/cli-engine/index.js\n- /usr/local/lib/node_modules/react-scripts/node_modules/eslint/lib/api.js\n- /usr/local/lib/node_modules/react-scripts/node_modules/eslint-webpack-plugin/dist/getESLint.js\n- /usr/local/lib/node_modules/react-scripts/node_modules/eslint-webpack-plugin/dist/linter.js\n- /usr/local/lib/node_modules/react-scripts/node_modules/eslint-webpack-plugin/dist/index.js\n- /usr/local/lib/node_modules/react-scripts/node_modules/eslint-webpack-plugin/dist/cjs.js\n- /usr/local/lib/node_modules/react-scripts/config/webpack.config.js\n- /usr/local/lib/node_modules/react-scripts/scripts/start.js","no-native-reassign",["151"],"no-negated-in-lhs",["152"],"jsx-a11y/accessible-emoji",[],"no-global-assign","no-unsafe-negation"]